@DATABASE "MuGuardianAngel"
@$VER: MuGuardianAngel.guide 1.19 (30.06.2018)
@(C) THOR Software
@INDEX Index
@SMARTWRAP
@AUTHOR Thomas Richter
@NODE MAIN "MuGuardianAngel Guide"
@{CODE}
       ´###         ,#.
      ,####        ,###
      ####'        ####
     ,####        ,###'
     ####'        ####          _________
    ,####        ,###'              |                 |
    ####'        ####               |    ___    ___   |   ___
   ,####        ,###'     ----      |   |   |  |   |  |  |___
   ####'        ####                |   |   |  |   |  |      |
  ,#####.      ,###'   .            |   |___|  |___|  |_  ___|
  ####'##.    ,####  ,##
 ,####  ########' # ,##'
 ####'   `####'   `###'
,####
#####                       © 1999-2018 THOR - Software,
####'                             Thomas Richter
`##'

____________________________________________________________________________

@{BODY}
                        MuGuardianAngel Guide

Guide Version 1.19                     MuGuardianAngel Version 40.51

____________________________________________________________________________


        MuGuardianAngel is based on the Guardian Angel © CBM,

        MungWall © 1992-93 Commodore-Amiga,

        MemSniff © 1999 Thomas Richter.

____________________________________________________________________________



@{"The Licence  : Legal restrictions                                       " link Licence}

@{"MuTools      : What is this all about, and what's the MMU library?      " link MMUOverview}

@{"Credits      : Thanks goes to...                                        " link Credits}

@{"What is it   : Overview                                                 " link Overview}

@{"Installation : How to install MuGuardianAngel                           " link Install}

@{"Synopsis     : The command line options and tool types                  " link Config}

@{"Developers   : How to allocate and release memory correctly             " link Develop}

@{"Patches      : System patches installed by MuGuardianAngel              " link Patches}

@{"Restrictions : What can it do, and what not?                            " link Restrictions}

@{"Output       : A tiny example output                                    " link Output}

@{"Detailed Ex. : A very detailed example output                           " link DetailExample}

@{"Hits         : The meaning of the MuGuardianAngel error messages        " link Hits}

@{"Problems     : Problematic programs and how to work around              " link Problems}


@{"History      : What happened before                                     " link history}

___________________________________________________________________________

MuGuardianAngel is a debugging tool. Software that causes MuGuardianAngel
hits will not run stable on a system without it. MuGuardianAngel helps you
to detect violations of the memory management of software, and it will even
protect memory up to a certain degree. However, MuGuardianAngel is NOT a
full automatic memory protector, which is likely impossible in the current
system. As a side effect, it may well keep a system from crashing when a
hit happens, but it may just as well make the software crash earlier. Due to
the way how it works, it will slow down your system to a certain degree.
MuGuardianAngel is mainly a development and testing tool, it shouldn't be
run permanently.


MuGuardianAngel causes no ill effects with correctly working software.
If a program fails to work while MuGuardianAngel is active, you should
contact the developer of that specific program.

When an access violation happens, a report such as the following is output:

     @{" Output Example " link Output}     @{" Detail Example " link DetailExample}

___________________________________________________________________________


        © THOR-Software

        Thomas Richter

        Rühmkorffstraße 10A



        12209 Berlin


        Germany



EMail:  thorfdbg\@alumni.tu-berlin.de

@ENDNODE
@NODE Licence "The THOR-Software Licence"
                         The THOR-Software Licence (v2, 24th June 1998)


This License applies to the computer programs known as "MuGuardianAngel" and
the "MuGuardianAngel.guide". The "Program", below, refers to such program.
The "Archive" refers to the package of distribution, as prepared by the
author of the Program, Thomas Richter. Each licensee is addressed as "you".



The Program and the data in the archive are freely distributable
under the restrictions stated below, but are also Copyright (c)
Thomas Richter.

Distribution of the Program, the Archive and the data in the Archive by a
commercial organization without written permission from the author to any
third party is prohibited if any payment is made in connection with such
distribution, whether directly (as in payment for a copy of the Program) or
indirectly (as in payment for some service related to the Program, or
payment for some product or service that includes a copy of the Program
"without charge"; these are only examples, and not an exhaustive enumeration
of prohibited activities).


However, the following methods of distribution
involving payment shall not in and of themselves be a violation of this
restriction:


(i) Posting the Program on a public access information storage and
retrieval service for which a fee is received for retrieving information
(such as an on-line service), provided that the fee is not
content-dependent (i.e., the fee would be the same for retrieving the same
volume of information consisting of random data).


(ii) Distributing the Program on a CD-ROM, provided that

a) the Archive is reproduced entirely and verbatim on such CD-ROM, including
especially this licence agreement;

b) the CD-ROM is made available to the public for a nominal fee only,

c) a copy of the CD is made available to the author for free except for
shipment costs, and

d) provided further that all information on such CD-ROM is re-distributable
for non-commercial purposes without charge.


Redistribution of a modified version of the Archive, the Program or the
contents of the Archive is prohibited in any way, by any organization,
regardless whether commercial or non-commercial. Everything must be kept
together, in original and unmodified form.




Limitations.


THE PROGRAM IS PROVIDED TO YOU "AS IS", WITHOUT WARRANTY. THERE IS NO
WARRANTY FOR THE PROGRAM, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY RIGHTS. THE ENTIRE
RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD
THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
SERVICING, REPAIR OR CORRECTION.


IF YOU DO NOT ACCEPT THIS LICENCE, YOU MUST DELETE THE PROGRAM, THE ARCHIVE
AND ALL DATA OF THIS ARCHIVE FROM YOUR STORAGE SYSTEM. YOU ACCEPT THIS
LICENCE BY USING OR REDISTRIBUTING THE PROGRAM.


                                                        Thomas Richter

@ENDNODE
@NODE MMUOverview "What's the MMU.library?"
All "modern" Amiga computers come with a special hardware component called
the "MMU" for short, "Memory Management Unit". The MMU is a very powerful
piece of hardware that can be seen as a translator between the CPU that
carries out the actual calculation, and the surrounding hardware: Memory
and IO devices. Each external access of the CPU is filtered by the MMU,
checked whether the memory region is available, write protected, can be hold
in the CPU internal cache and more. The MMU can be told to translate the
addresses as seen from the CPU to different addresses, hence it can be used
to "re-map" parts of the memory without actually touching the memory itself.


A series of programs is available that make use of the MMU: First of all,
it's needed by the operating system to tell the CPU not to hold "chip
memory", used by the Amiga custom chips, in its cache; second, several tools
re-map the Kickstart ROM to faster 32Bit RAM by using the MMU to translate
the ROM addresses - as seen from the CPU - to the RAM addresses where the
image of the ROM is kept. Third, a number of debugging tools make use of it
to detect accesses to physically unavailable memory regions, and hence to
find bugs in programs; amongst them is the "Enforcer" by Michael Sinz.
Fourth, the MMU can be used to create the illusion of "almost infinite
memory", with so-called "virtual memory systems". Last but not least, a
number of miscellaneous applications have been found for the MMU as well,
for example for display drivers of emulators.


Unfortunately, the Amiga Os does not provide ANY interface to the MMU,
everything boils down to hardware hacking and every program hacks the MMU
table as it wishes. Needless to say this prevents program A from working
nicely together with program B, Enforcer with FastROM or VMM, and other
combinations have been impossible up to now.


THIS HAS TO CHANGE! There has to be a documented interface to the MMU that
makes accesses transparent, easy and compatible. This is the goal of the
"mmu.library". In one word, COMPATIBILITY.


Unfortunately, old programs won't use this library automatically, so things
have to be rewritten. The "MuTools" are a collection of programs that take
over the job of older applications that hit the hardware directly. The
result are programs that operate hardware independent, without any CPU or
MMU specific parts, no matter what kind of MMU is available, and programs
that nicely co-exist with each other.


I hope other program authors choose to make use of the library in the future
and provide powerful tools without the compatibility headache. The MuTools
are just a tiny start, more has to follow.

@ENDNODE
@NODE Overview "What's the job of MuGuardianAngel?"
MuGuardianAngel is an extension to the "MuForce" program. Where MuForce
detects only accesses to un-available address regions, MuGuardianAngel will
also protect "free" memory from getting overwritten or accessed at all. In
case a program accesses memory without allocating it properly from the
system, MuGuardianAngel will report that hit by the magic of the "MuForce"
program.


MuGuardianAngel makes use of the mmu.library to setup the MMU to watch
illegal accesses to pages of non-allocated, but in principle available
memory. This is something different to MuForce which will only catch
accesses to unavailable memory regions.


MuGuardianAngel will, additionally, provide all the functionality of the
"MungWall" and "MungList" tools. All memory allocations are "munged"
and watched for "out of range" accesses or illegal memory releases.


MuGuardianAngel can, optionally, snoop memory allocations and report them
over the serial port. It may also check the memory list for consistency on a
regular basis or report which memory regions are allocated by which task.


If SegTracker is running in the system when MuGuardianAngel is started,
it will use the public SegTracker seglist tracking for identifying the hits.


For short, MuGuardianAngel replaces four tools in one:

The original "Guardian Angel" which never really worked. "MuGuardianAngel"
will. The "MungWall" tool, except that the "MuGuardianAngel" dumps more
information. The "MungList" tool. The "MemSniff" tool by the same author.


When an access violation happens, a report such as the following is output:

     @{" Output Example " link Output}     @{" Detail Example " link DetailExample}


@ENDNODE
@NODE Install "Installation of MuGuardianAngel"
Installation is pretty simple:


- First, install the "mmu.library": Copy this library to your LIBS:
drawer if you haven't installed it yet. It's contained in this archive.


- Install "MuForce" first. It is required by MuGuardianAngel.

- Copy "MuGuardianAngel" wherever you want.

- Remove other Enforcer tools like the "Enforcer" or the "CyberGuard",
remove "MungWall", "MungList" and "MemSniff" as well. Detach MuGuardianAngel
*after* MuForce, and possibly after SegTracker. Just start it like:


run >NIL: <NIL: MuGuardianAngel


plus all the @{"options" link Config} you wish.


Since "MuGuardianAngel" dumps it output over the serial port by default, it
is possibly a smart idea to install "Sushi" or "Sashimi", too, in case no
serial terminal is available. This tool will redirect the "MuGuardianAngel"
output to a console window. Alternatively, use the
@{"TOMUFORCE" link Option_TOMUFORCE} option to redirect the output to the
MuForce stream, wherever this goes.


You can also run "MuGuardianAngel" from the workbench, it will read its
options from the tooltypes in this case.


@{B}IMPORTANT:@{UB} It is *very* important that you do not install *ANY*
patch on top of MuGuardianAngel. MuGuardianAngel will be no longer able to
detect the return PC of the calling code; moreover, this will break the
kludge for the layers.library and will therefore cause system crashes.


One exception:  "ShowMem" releases 2.06 or better can be used safely because
they jump into the allocation routine and do not call them.


@{B}IMPORTANT:@{UB} Do *NOT* quit MuForce as long as MuGuardianAngel is
running! This will most likely crash your machine!


@{B}IMPORTANT:@{UB} It might be possible that you have to run certain
"fixes" to work-around some "features" of certain programs and to keep
MuGuardianAngel happy. They are intentionally @{B}not@{UB} included in
MuGuardianAngel itself.


        @{"More details about this" link Problems}

@ENDNODE
@NODE Config "Command line options and tooltypes"
MuGuardianAngel can be started either from the workbench or from the
shell. In the first case, it reads its arguments from the "tooltypes" of its
icon; you may alter these settings by selecting the "MuGuardianAngel"
icon and choosing "Information..." from the workbench "Icon" menu. In the
second case, the arguments are taken from the command line. No matter how
the program is run, the arguments are identical.

@{CODE}
The options for MuGuardianAngel are as follows:

     @{" QUIT          " link Option_QUIT}    @{" MUNGLIST      " link Option_MUNGLIST}    @{" PRI=PRIORITY  " link Option_PRI}
     @{" CLIENT=TASK   " link Option_TASK}    @{" WAIT          " link Option_WAIT}    @{" SNOOP         " link Option_SNOOP}
     @{" MIN           " link Option_MIN}    @{" MAX           " link Option_MAX}    @{" DEBUG         " link Option_DEBUG}
     @{" SHOWFAIL      " link Option_SHOWFAIL}    @{" SHOWSTACK     " link Option_SHOWSTACK}    @{" SHOWPC        " link Option_SHOWPC}
     @{" SHOWHUNK      " link Option_SHOWHUNK}    @{" STACKLINES    " link Option_STACKLINES}    @{" NAMETAG       " link Option_NAMETAG}
     @{" DATESTAMP     " link Option_DATESTAMP}    @{" STACKSNOOP    " link Option_STACKSNOOP}    @{" CONSISTENCY   " link Option_CONSISTENCY}
     @{" PRESIZE       " link Option_PRESIZE}    @{" POSTSIZE      " link Option_POSTSIZE}    @{" FILLCHAR      " link Option_FILLCHAR}
     @{" LED           " link Option_LED}    @{" INTRO         " link Option_INTRO}    @{" DISABLEBELL   " link Option_DISABLEBELL}
     @{" TINY          " link Option_TINY}    @{" DREGCHECK     " link Option_DREGCHECK}    @{" AREGCHECK     " link Option_AREGCHECK}
     @{" STACKCHECK    " link Option_STACKCHECK}    @{" TOMUFORCE     " link Option_TOMUFORCE}    @{" DISPC         " link Option_DISPC}
     @{" DISRANGE      " link Option_DISRANGE}    @{" NOMMU         " link Option_NOMMU}    @{" ALLOWREUSE    " link Option_ALLOWREUSE}
     @{" DUMPWALL      " link Option_DUMPWALL}    @{" NOSTACKWARN   " link Option_NOSTACKWARN}    @{" MINSTACK      " link Option_MINSTACK}
     @{" WAITFORMUFORCE" link Option_WAITFORMUFORCE}    @{" PROTECTPOST   " link Option_PROTECTPOST}

@{BODY}
____________________________________________________________________________


When started from the workbench, MuGuardianAngel knows one additional
tooltype, namely:

        WINDOW=<path>

where <path> is a file name path where the program should print its output.
This should be a console window specification, i.e. something like


CON:0/0/640/100/MuGuardianAngel


This argument defaults to NIL:, i.e. all output will be thrown away.


It is possibly a good idea, in case no serial terminal is available, to
install a tool like "Sushi" or "Sashimi" to catch the MuGuardianAngel hits
and print them to a console window instead over the serial line.

____________________________________________________________________________

@ENDNODE
@NODE Credits "Credits : Thank you goes to..."
Michael Sinz (a real *BIG* thank you!) for discussing a lot of details of
CachePreDMA/CachePostDMA, for sending me the sources of these functions in
his 68040, and especially - and that's really great - for making the
Enforcer sources available.


Ralph Babel for giving information about the CachePreDMA/CachePostDMA
functions and for taking the time and helping me a bit with the messy
details.


Bjoern Schmidt and Oliver Spaniol for allowing me to run some tests on their
060 based machines.


Werner Müller for his 040 based system.


All the testers for running tests and sending me detailed information about 
their systems. Thank you to all of you, this project won't clearly possible
without your support!

@ENDNODE
@NODE Develop "Correct memory handling: Avoiding hits"
In case you wonder how MuGuardianAngel hits can be avoided, here are the
rules how memory should be allocated and released correctly.


The following rules apply to all programs that are supposed to run in an OS
friendly way. I didn't make them up myself. What you find here is more or
less a copy of the rules taken from the ROM Kernel reference manual, the
official Amiga developer documentation.

Breaking these rules will result in unstable programs, with or without
any additional memory tools. A program that causes hits with MuGuardianAngel
but runs fine otherwise is, nevertheless, unstable and might crash
in certain situations.

@{CODE}
Allocation of memory:

o)      The MEMF_PUBLIC bit:
        Set the MEMF_PUBLIC bit (exec/memory.h). You usually want it!

        NOT setting this bit results in memory that is
        a) *private* to your task, i.e. can't be read from any other task
        b) and can't be read safely within a Forbid()/Permit() or
        Enable()/Disable() pair.
@{BODY}

The current Os DOES NOT implement any checks for this rule, neither
does MuGuardianAngel. Since private memory is not under direct control of
MuGuardianAngel, this type of memory is never made unavailable or touched
otherwise by this debugging tool. Future memory managers might see this
bit as a hint to assign "virtual memory" to the allocation, i.e. memory
that can be swapped out to disk.


As an example, VMM requires correct usage of this bit.


All data that is supposed to hold Os structures MUST BE ALLOCATED
WITH THE MEMF_PUBLIC flag set, any memory that is passed to other
tasks, interrupts, exceptions, I/O buffers MUST BE ALLOCATED WITH THIS BIT
SET.


The only exception are private structures that are only read
or written to by your task, that are never passed nor read or
written to by other processes or Os functions and that are not
accessed with multitasking disabled.

@{CODE}

o)      Memory flushes:

@{BODY}
Be prepared that a memory allocation might flush unused libraries,
fonts and devices from memory. In special, DO NOT USE CLOSED
RESOURCES. Using a "FindName()" on the exec resource lists IS NOT
ENOUGH to use a resource.

@{CODE}
        If you DO NOT want that resources get flushed, set the
        MEMF_NO_EXPUNGE flag as memory attribute. See exec/memory.h.


        The following is a safe memory flush:

        AllocMem(0x7ffffff0,MEMF_PUBLIC);

        (The flush used by the "avail flush" command).
@{BODY}

MuGuardianAngel will never report a memory flush as a failed memory
allocation. This is different to "MungWall".


@{CODE}
o)      Memory and custom chips:

        Memory that should be read by the Amiga custom chip set MUST BE
        ALLOCATED with the MEMF_CHIP attribute set or the custom chips
        won't be able to address this memory. That goes for:

        o) display buffers (native bitmaps)
        o) hardware copper lists (but not their gfx abstractions for the
           CMove(),CWait() etc... family)
        o) image bitmaps (struct IntuiImage->ImageData)
        o) floppy hardware buffers (but since V37 not required for the
           trackdisk.device I/O buffer)
        o) hardware audio buffers
        o) hardware sprites and image datas of "Bobs"
        o) everything else the custom chip set might access     


o)      Order of memory blocks:

        Do not make *any* assumptions about the order in which you get
        memory. The second allocation is not necessarily the higher
        address!

o)      The MEMF_FAST bit:

        Do not use the MEMF_FAST bit unnecessary if chip mem would be
        O.K. for you, too. The operating system is smart enough to
        allocate fast memory for you if that is available. It will fall
        back to chip mem if fast mem is not available. There's usually
        no reason to ask for fast mem explicitly.

o)      Alignment:

        It is guaranteed that all memory allocated by AllocMem() is aligned
        to two long word boundaries, i.e. the bits 0 to 2 of the address will
        always be zero. NOT MORE! If you need more alignment, see the kludge
        below.

o)      Size of buffers:

        Make sure you allocate enough memory even for the worst case. A
        C style string needs n+1 bytes memory to hold a string of length n.
        Some Os functions require, due to bugs, a slightly larger buffer
        than you might think, check the "BUGS" section of the autodocs.
        (Mostly dos functions suffer from this bug, but some intuition
        functions require this as well).

@{BODY}
MuGuardianAngel is able to detect *some* out-of-range accesses of memory,
but usually only at the time the memory is released again.

@{CODE}
o)      Memory attributes:

        Do NOT set ANY undocumented bits for the memory attributes of
        AllocMem(). They *might* be ignored for this version of the Os,
        but probably won't by the next version. Check the exec/memory.h
        file for valid flags. As for the current (V40) version of the Os,
        the following flags have been defined:

#define MEMF_ANY    (0L)        /* Any type of memory will do */
#define MEMF_PUBLIC (1L<<0)     /* D*mn important, see caveats above !*/
#define MEMF_CHIP   (1L<<1)     /* for custom chips */
#define MEMF_FAST   (1L<<2)     /* explicitly fast mem, see caveats! */
#define MEMF_LOCAL  (1L<<8)     /* Memory that does not go away at RESET */
#define MEMF_24BITDMA (1L<<9)   /* DMAable memory within 24 bits of address */
#define MEMF_KICK   (1L<<10)    /* Memory that can be used for KickTags */

#define MEMF_CLEAR   (1L<<16)   /* AllocMem: NULL out area before return */
#define MEMF_LARGEST (1L<<17)   /* AvailMem: return the largest chunk size */
#define MEMF_REVERSE (1L<<18)   /* AllocMem: allocate from the top down */
#define MEMF_TOTAL   (1L<<19)   /* AvailMem: return total size of memory */


o)      Memory contents:

        Do NOT MAKE any assumption about the contents of the memory block
        unless you specified the MEMF_CLEAR attribute to erase the memory
        block. Not setting this bit is a bit faster, but results in a
        memory block with whatever contents you might dream of.

@{BODY}
MuGuardianAngel tries to be a bit nasty to programs that do not allocate
memory with MEMF_CLEAR. Instead leaving the memory like it is, it will fill
the memory region with a special non-zero pattern.

@{CODE}
o)      Self modifying code:

        Self modifying is discouraged.

        If you absolutely MUST play with this and can't go 'round this,
        use the following Os call to flush the CPU caches once you've
        placed your code in memory and need to run it:

        ClearCacheU()

        Do NOT expect that it is there BEFORE you called this routine.
        This is even more important to routines like interrupts that are
        called asynchronously.

o)      Failures:

        Feel prepared that your memory request might fail. An explicit
        check is REQUIRED after an AllocMem() call. Just "going guru" in
        this case *IS NOT ENOUGH*. Print a warning message, abort your
        program safely, CHECK YOUR CODE!

        Assembly language authors: NO, IT'S NOT DOCUMENTED THAT AllocMem()
        SETS THE ZERO BIT IF THE ALLOCATION FAILED. YOU'VE TO TEST THAT
        YOURSELF.

        If your calling task is indeed a process, OS versions V37 and
        above guarantee to set the result code for IoErr() to
        ERROR_NO_FREE_STORE (=103L).

@{BODY}
MuGuardianAngel will show failed memory allocations if the
@{"SHOWFAIL" link Option_SHOWFAIL} option was turned on. Furthermore, it
tries to be nasty to programs and messes the scratch registers d1/a0-a1 or
d0-d1/a0-a1 before leaving the memory handling routines. It will also set
the Z flag to fool assembly programs failing to test d0 correctly.

@{CODE}
o)      AllocMem() and context switches:

        Neither AllocMem() nor FreeMem() break a "Forbid" state. This is
        important because it's the only way to "print" a list thru the
        dos.library and other functions that is access protected
        via Forbid().

        The following code sequence is legal for this purpose, and should
        stay legal:

        - call Forbid() first,
        - make a copy of that list element by element, using AllocMem()
        - call Permit().
        - print the copy of the list
        - deallocate the copy.

        Running into a Wait(), like using a semaphore for access protection
        of the memory list memory would be fatal here.


o)      AllocMem,FreeMem,AllocAbs and interrupts:

        NONE of these functions can be called from interrupts or in the
        supervisor mode.

        Remember, however, that "input handlers" of the input.device
        are not run as interrupts but in the context of the input.device
        task, even though they are build on top of an interrupt structure.
        Thus, calling AllocMem() here to make a copy of an input event IS
        LEGAL.

_____________________________________________________________________________


o)      Size of deallocation:

        Deallocation size MUST MATCH ALLOCATION SIZE PRECISELY. It is
        BY NO MEANS ALLOWED to

        - round the size because the rounding algorithm of the operating
          system might change in future to support special hardware
          (e.g. PowerPC cache lines which are 32 bytes wide)

        Now to another rule that hasn't been formulated in the RKRMs:

        - free a partial memory block, i.e. parts of an array.
          THIS IS DEFINITELY ILLEGAL, NO EXCEPTIONS, NO EXCUSES.
          Free ALL OR NOTHING.

        Freeing a partial part of a memory block requires knowledge of
        the alignment rules of the Os and may break code if these rules
        change in future versions.

        I would therefore strongly recommend NOT to use this technique.

@{BODY}
MuGuardianAngel will "hit" in case a program tries to release a memory block
by a different size than it was allocated with. It will furthermore hit if a
program tries to release "unaligned" memory, i.e. a memory block not aligned
to an eight-byte border. (However, see below for an important exception.)


The V37 and below implementation of the layers.library does not obey the
rule formulated above (yuck!) and is therefore explicitly excluded from
memory snooping and munging. It releases, unfortunately, partial memory
blocks.

@{CODE}
o)      Access to deallocated memory:

        Do not touch deallocated memory. If it's gone it's gone and you're
        no longer allowed to use it, address it, read it or write data to
        it. Another task might want it.

@{BODY}
MuGuardianAngel will mark released memory as unavailable as soon as
possible. In case you try to access this memory, you'll see a hit.

@{CODE}
        A tiny exception that hasn't been formulated in the RKRMs, but is
        unfortunately widely used:

        Deallocation of memory WITHIN a Forbid()/Permit() pair. The memory,
        EXCEPT FOR THE FIRST EIGHT BYTES WHICH ARE USED FOR ADMINISTRATION,
        is guaranteed to stay unmodified and ready for use as long as
        the multitasking is disabled. Running into a Wait(), directly or
        indirectly, will break the Forbid() state and will therefore make
        the memory unusable.

@{BODY}
Be warned! Even though this access is sort of legal, hence tolerated by
MuGuardianAngel, is IMHO still ugly and therefore highly discouraged. One of
the very few exceptions where this feature might be helpful is the following
code segment that unloads the segment of a "load- and stay resident"
program:

@{CODE}
        move.l SysBase(a4),a6
        jsr _LVOForbid(a6)
        move.l DOSBase(a4),a6
        move.l Segment(a4),d1
        jsr _LVOUnloadSeg(a6)   ;Unload own code
        move.l a6,a1            ;THIS CODE STAYS LEGAL because
        move.l SysBase(a4),a6   ;of the Forbid()
        jsr CloseLibrary(a6)    ;close dos
        moveq #0,d0
        rts                     ;exit.

@{BODY}
Note that you must be definitely positively sure that the segment is not an
overlayed segment because UnloadSeg() WILL break the Forbid() state in this
case. However, this doesn't work for load- and stay-resident programs
anyways.


MuGuardianAngel does, currently, guarantee that memory will be not made
unavailable if it is released within a Forbid(). It will be made unavailable
as soon as the Forbid() is broken. UNLIKE MungWall, MuGuardianAngel *does*
munge this memory and will, too, check it for consistency as soon as it is
allowed to do. It will, actually, check the memory twice. Once FreeMem() is
called, and once again MuGuardianAngel is allowed to make it unavailable.


@{CODE}
o)      Chip memory and blitter access.

        The custom "blitter logic" uses DMA and accesses the chip memory
        independent of the CPU. If you use a temporary buffer for the blitter,
        make sure the blitter does no longer access this buffer before you
        deallocate it. To be on the safe side, call WaitBlit() before de-
        allocating memory that has been used as blitter buffer.

@{BODY}
MuGuardianAngel cannot, unfortunately, detect illegal chip ram accesses by
the blitter because this is out of control of the MMU.

@{CODE}
o)      Memory and hardware DMA access:

        Modern hard disk interfaces might access memory by DMA, parallel
        to the CPU. If you're planning to use this hardware DMA directly
        because you're writing a device driver for this hardware, be
        prepared to flush the CPU caches properly. Especially, call

        CachePreDMA(...)
                prior the DMA operation

        CachePostDMA(...)
                afterwards.

        Check the autodocs for details about these functions and their
        parameters. Read them, then think about them, then read them
        again. It is important that you understand them correctly!


o)      Return value:

        FreeMem() DOES NOT return any useful value, nor does it set any
        condition codes.

@{BODY}
As always, MuGuardianAngel will try to be nasty to programs and will
invalidate the scratch registers and the condition codes.

______________________________________________________________________________


AllocAbs and other weirdos:


AllocAbs is for specialized usage of allocating memory from a predefined
location. DO NOT USE IT WITHOUT GOOD REASON.

@{CODE}
o)      Range of allocated memory:

        AllocAbs performs some rounding. Be prepared that the memory block
        you get is not identical to the memory block you requested.
        However, IF the memory allocation could be satisfied, the requested
        memory block is guaranteed to be contained in the returned memory
        block.
        Feel prepared that the memory request cannot be satisfied because
        the requested memory is already in use by a different task.

        AllocAbs() returns NULL in this case. You've to check for this
        explicitly! It does NOT set any condition codes.

        AllocAbs() WILL NOT set the ERROR_NO_FREE_STORE return code for
        IoErr().
@{BODY}

MuGuardianAngel will, again, fill the scratch registers with dummy values
and set the Z flag to fool badly written programs of a failure condition.

@{CODE}
o)      Contents of allocated memory:

        Do not make any assumptions about the contents of the
        allocated memory block. The OS uses parts of the free memory blocks
        for administrator purposes and might have been trashed parts of
        memory block.

        That means especially for reset resident programs - whose memory is
        allocated this way by the exec KickMemPtr mechanism - that the
        first eight bytes will be trashed. Be prepared for this feature!

@{BODY}
MuGuardianAngel will trash the allocated memory explicitly, but it will not
snoop AllocAbs() allocations.

@{CODE}
o)      Deallocation of AllocAbs()-ed memory:

        To be sure that the allocated memory is really deallocated
        completely, call FreeMem with the memory address and size you
        REQUESTED, NOT with the return value of AllocAbs(). This might
        sound strange indeed, but the FreeMem() logic performs the same
        rounding of size and address as the AllocAbs() logic. If, however,
        you pass in a different address, as the return value instead of the
        requested address, it is not guaranteed that really all memory is
        deallocated.

        A tiny example might be helpful (assuming the the current rounding
        algorithm):

        AllocAbs(0x07,0x300007);

        allocates 16 bytes and returns 0x300000. Calling now

        FreeMem(0x300000,0x07);

        will only free EIGHT bytes starting from 0x300000 instead of
        16 bytes. However,

        FreeMem(0x300007,0x07);

        will work as required.

@{BODY}
MuGuardianAngel will detect the last FreeMem() as misaligned,
though. You should ignore its hit in this case.

@{CODE}
o)      Using AllocAbs() for aligned memory allocation:

        The following code segment is a kludge for allocating memory aligned
        to a boundary:

void *AllocAligned(ULONG bytesize,ULONG attributes,ULONG alignment)
{
UBYTE *mem,*res;

        alignment--;
        if (mem=AllocMem(bytesize+alignment,attributes & (~MEMF_CLEAR))) {
        Forbid();
        FreeMem(mem,bytesize+alignment);
        mem = (mem + alignment)&(~alignment);
        res = AllocAbs(bytesize,mem);
        Permit();
        if (res) {
                if (attributes & MEMF_CLEAR)
                        memset(mem,0,bytesize);
                } else mem = NULL;
        }
        return mem;
}

        I.e, call this routine with "alignment" set to 16 for an alignment
        to a sixteen byte boundary.
        Calling this routine with anything but a power of two for the
        alignment doesn't make much sense and is illegal.

        Note that the memory is cleared MANUALLY if MEMF_CLEAR is set.
        This MUST be done since AllocAbs() does not guarantee the
        contents of the memory, even if the former AllocMem() already
        cleared the memory.
@{BODY}
_____________________________________________________________________________


Any program that obeys these rules won't cause *any* problems with
MuGuardianAngel!

_____________________________________________________________________________


Debugging tools:


In case you write a debugger and you really, really *MUST* read
non-allocated memory, then go to supervisor mode to read it. MuGuardianAngel
will only detect memory accesses to "free" memory from user mode.


The following debugging tools are recommended:

@{CODE}
-MuForce:               Detects memory accesses to the vector base and to
                        unmapped memory regions.

-MuGuardianAngel (-: :  Detects memory accesses to "free" memory, illegal
                        and out of range accesses, and the problems
                        mentioned above.

-SegTracker:            Keeps program names together with their loaded
                        segments for easy identification of code. Used
                        by the programs above.

-PatchWork:             Detects invalid parameters to Os calls.

-Sashimi:               Redirects MuGuardianAngel hits to a console window.

-SaferPatches:          Detects illegal function patches. If this one
                        crashes with a guru, something is wrong.

@{BODY}
Even a program that runs without problems with these tools is not
necessarily bug free!

_____________________________________________________________________________


Another set of weirdos for the "enlighted". (-:


The following is a list of "OS features" you should be aware of if you
consider writing your own memory tool. I found them when writing PoolMem,
so they are here for your information. However, DO NOT USE THESE TECHNIQUES
in own code.


Even though the above rules have been setup for the developer, that doesn't
mean that the Os respects these rules ("Quod licet Iovi non licet bovi.").


I found the following "OS features":

@{CODE}
- The FFS (all versions V37 thru V43) expect a return value of "-1" for
  FreeMem(). This has been fixed for release 43.20.
@{BODY}

MuGuardianAngel will therefore cause a strange result code for Close() for
FFS releases below 43.20.


@{CODE}
- The V37 layers.library allocates memory in large blocks, but deallocates
  this large block of memory in a series of small deallocations. In other
  words, it breaks up large memory blocks in smaller ones.

@{BODY}
The current version of MuGuardianAngel include a special kludge
to allow this EXCLUSIVELY for the layers.library. However, THIS HAS BEEN
ILLEGAL, IS ILLEGAL AND WILL CONTINUE TO BE ILLEGAL. I hope this mess
has been cleaned up in V39.

@{CODE}
- Some programs expect the Z (zero) flag of the CPU after an AllocMem()
  call to be set on failure and to be cleared if the allocation worked.
  THIS IS UNDOCUMENTED.
@{BODY}

MuGuardianAngel will break these programs on purpose.

@ENDNODE
@NODE Patches "System patches installed by MuGuardianAngel"
MuGuardianAngel replaces the following system functions completely - this
means that all other patches installed here will be no longer called:


@{CODE}
AllocMem:
        replaced completely. The replacement function includes memory
        snooping, munging and marks the allocated memory valid.
        It contains, too, a consistency check.


FreeMem:
        replaced completely. Adds consistency checks for the deallocated
        memory and for the mungwall. Furthermore, memory is made
        unavailable and filled with a special cookie to detect memory
        modifications that somehow slipped thru the protection mechanism.


AllocAbs:
        replaced completely. It will, too, make the allocated memory
        available and fill the memory with a dummy pattern.


AvailMem:
        replaced completely. The calculation algorithm is modified to
        include the size of the mungwalls.


AllocPooled:
        replaced completey by a procedure that includes the memory munge.


FreePooled:
        replaced completely.


CreatePool:
        replaced completely, includes sanety checks of the arguments and
        an adjustment of the puddle and thressizes for the pool to include
        the mung wall.

DeletePool:
        replaced completely.

AllocVec:
        replaced completely. This call will also trash scratch registers and
        include an indicator that the memory has been allocated as a vector.

FreeVec:
        replaced completely.

Allocate:
        replaced completely. Memory allocated from private pools by
        Allocate() does not get a memory cookie since, in general, memory
        in such pools are administrated by the programs managing the pool.

Deallocate:
        replaced completely. This also clears the released memory and
        trashes the registers.

@{BODY}


The replacement functions will never call the exec Alert() function to
create a guru. Instead, all possible failures will be passed over to the
MuGuardianAngel error handler and will be printed "in text".


MuGuardianAngel installs furthermore a "Page Access Handler" into the public
MMU context, in order to be notified in case some other program tries to
modify the MMU tree. The handler won't touch any page except those
consisting completely of free memory, and will mark these pages as
non-available. It remains therefore compatible to MuFastRom and others.


MuGuardianAngel modifies the MMU pages at the lower of the two available
levels, its function is therefore transparent to programs making use of the
high-level functions.


@{B}IMPORTANT:@{UB} It is *very* important that you do not install *ANY*
patch on top of MuGuardianAngel. MuGuardianAngel will be no longer able to
detect the return PC of the calling code; moreover, this will break the
kludge for the layers.library and will therefore cause system crashes.


One exception:  "ShowMem" releases 2.06 or better can be used safely because
they jump into the allocation routine and do not call them.

@ENDNODE
@NODE Restrictions "MuGuardianAngel restrictions"
MuGuardianAngel is a powerful tool, but it has its quirks and its price:


- MuGuardianAngel will make your system slow. Since all memory allocations
are watched and munged, every allocation will take much more time than it
used to.


- The current version MuGuardianAngel does not work in case the exec free
memory list contains re-mapped memory. This will change in a future version.


- MuGuardianAngel tries to detect a lot of hits, but it won't be able to get
all bad memory accesses. It cannot detect an access to memory owned by a
different task because it is not clear whether this access is intended or
not. The AmigaOs memory model is completely shared, so there's no way to
find this out. It might even fail to detect some accesses into "free" memory
due to the page size granularity. Write accesses into this free memory will
be found most likely, but only as soon as some other task tries to allocate
the damaged memory. It is then, unfortunately, too late to find the task
that was responsible for the problem. However, this is not the "typical"
case anyways.


- MuGuardianAngel tries to give you as much information as possible, this is
in most cases more than - for example - MungWall could. But it is still
unable to give you a task name or a stack dump for certain hits. These are
mainly limitations that arise in the construction of the AmigaOs, there's no
easy way to fix it.


- MuGuardianAngel will eat some memory. The program itself is small, but
since each allocation is enlarged to keep a "mung wall", programs will
require more memory than before.


- The "STACKSNOOP" option is most un-useful. )-:


- MuGuardianAngel requires a MMU - unlike MungWall or MemSniff. But it is
able to detect a lot more hits than MungWall and is faster than MemSniff.


@ENDNODE
@NODE Hits "MuGuardianAngel error messages"
MuGuardianAngel may produce the following types of "hits":


@{CODE}
@{"Clear memory cookie at .. was found defective" link Hit_Cookie}
@{"Release of .. :alloc. length .. <> released length .." link Hit_BadSize}
@{"Release of .. :allocation pool .. <> release pool .." link Hit_BadPool}
@{"Front Mung-wall at .. is damaged" link Hit_BrokenWall}
@{"Rear Mung-wall at .. is damaged" link Hit_BrokenWall}
@{"MemHeader of chunk .. is not available" link Hit_InvalidFreeMem}
@{"Memory at .. released twice" link Hit_FreeTwice}
@{"Invalid FreeMem of memory at .." link Hit_WithinChunk}
@{"Hit: Mem header ..: free counter .. <> .. in chunks" link Hit_FreeMisMatch}
@{"Null-sized allocation, ignored" link Hit_NullSized}
@{"FreeMem of NULL pointer attempted, ignored" link Hit_FreeNULL}
@{"Misaligned release of .., size .. performed" link Hit_MisFree}
@{"Allocation of .. bytes failed" link Hit_AllocFailed}
@{"Task ..: nearly out of stack" link Hit_NearlyOut}
@{"Task ..: stack overflow" link Hit_Overflow}
@{"Task ..: stack underflow" link Hit_Underflow}
@{"Invalid memory list" link Hit_InvMemList}
@{"Mem header ..: node type is not NT_MEMORY" link Hit_BadType}
@{"Mem header ..: lower is larger than upper" link Hit_BadHeader}
@{"Mem header ..: chunk .. <lower or >upper" link Hit_BadChunk}
@{"Mem header ..: chunk .. order broken" link Hit_Unsorted}
@{"Mem header ..: chunk after .. misaligned" link Hit_MisChunk}
@{"MuGuardianAngel patches have been overwritten" link Hit_PatchWarn}
@{".. called from interrupt or supervisor mode" link Hit_IRQMode}
@{"CreatePool puddleSize .., thresSize .. invalid" link Hit_InvCreate}
@{"CreatePool failed" link Hit_CreateFailed}
@{"DeletePool of NULL pointer attempted, ignored" link Hit_NULLPool}
@{"Alloc/FreePooled from NULL pool attempted" link Hit_NULLPoolAlloc}
@{"Memory pool .. garbled" link Hit_PoolGarbled}
@{BODY}

However, since MuGuardianAngel makes certain memory regions unavailable by
the MMU, programs accessing these regions will not be handled by
MuGuardianAngel but by "MuForce". For details about the output of this
program, check the "MuForce.guide".

@ENDNODE
@NODE Problems "Common problems"
Here's a list of problematic programs:


@{B}The "cybscsi.device":@{UB}


Due to a firmware "feature", this program causes a hit every second on each
disk access. The background is that the device driver accesses a chip memory
location to slow down the code by a well-defined amount of time. However,
since that memory is not allocated, MuGuardianAngel will "hit" totally
justified. To work around this problem, run the "FixCybAccess" program
before running the MuGuardianAngel.


@{B}The "Ram-Handler":@{UB}


Yes, you read that correctly, the Commodore RAM: disk is buggy. As soon as
you try to read and write to the RAM disk simulatenously, strange and
wonderful things may happen.

Futhermore, the RAM handler is setup with a too small stack. This
@{B}should@{UB} be fixed by running "PatchRAM" somewhere in the
startup-sequence, before the RAM disk gets used.




@{B}The "console.device":@{UB}


And yes, yet another ROM bug. Due to a bug in the console.device supervisor
task, an illegal memory location *might* be accessed as soon as a console
window gets resized. This is fixed by the "ConsoleFix" patch in this
archive.



@{B}The "FFS":@{UB}


Not really a problem of the FFS, but for some installations. Sometimes the
FFS has been setup with too little stack size, so MuGuardianAngel will
complain about a possible stack overflow of the filing system. This should
be fixed manually by increasing the stack size in the RDB block. This step
is left to the expert as an easy exercise. (-:



@{B}The "narrator.device":@{UB}


This is another example of a system program that is too low on stack space.
A patch for the 37.7 edition of the device is available in the "Fixes"
directory of the "MMULib" distribution. It should be applied during
installation of the MMU.library.



@{B}Executive:@{UB}


Due to some reason not yet known by the author, Executive seems to be
incompatible to MuGuardianAngel.



@{B}PatchWork:@{UB}


In case you run PatchWork in conjunction with MuGuardianAngel, please
ensure that you run PatchWork @{B}first@{UB} and
@{B}MuGuardianAngel@{UB} afterwards.



@{B}FastExec:@{UB}


This is a very ugly hack that should be avoided anyhow. It should be
replaced by "MuMove4K" and "MuFastZero FastExec".



@{B}In case nothing helps:@{UB}


Here are a few additional tips and hints how to make MuGuardianAngel working
if everything else fails:


o)      Remove system patches. MuGuardianAngel is @{B}very@{UB} critical.


o)      As a workaround, try the options

        @{"ALLOWREUSE" link Option_ALLOWREUSE} and @{"PRI=-1" link Option_PRI}


o)      If even that doesn't help, try

        @{"NOMMU" link Option_NOMMU}

@ENDNODE

@NODE Option_QUIT "Option: QUIT"
QUIT=OFF/S


Tells MuGuardianAngel to quit.  MuGuardianAngel can also be stopped by
sending a CTRL-C to its process.

@ENDNODE
@NODE Option_MUNGLIST "Option: MUNGLIST"
MUNGLIST/S

This option is only available if another copy of MuGuardianAngel is already
running. In this case, it will dump all the memory that has been allocated
by programs thru MuGuardianAngel. The options @{"MIN" link Option_MIN} and
@{"MAX" link Option_MAX} should be used to specify a region of interest,
only allocations of sizes between these borders will be printed.


You may also specify the name of a task using the
@{"TASK" link Option_TASK} option to dump only allocations performed by a
certain task. However, @{"TASK" link Option_TASK} works only if the former
copy of MuGuardianAngel was told to keep task names, by specifying the
@{"NAMETAG" link Option_NAMETAG} option at startup time.

@ENDNODE
@NODE Option_PRI "Option: PRIORITY"
PRI=PRIORITY/K/N

Specifies the priority of the MuGuardianAngel process. It defaults to "80"
and should be rather high to be effective. There is little reason to adjust
this.


The MuGuardianAngel process is required to update the
@{"DATESTAMP" link Option_DATESTAMP} frequently and to release memory that
was FreeMem()'ed in the FORBID state.

@ENDNODE
@NODE Option_TASK "Option: TASK"
CLIENT=TASK/K

If used with the @{"MUNGLIST" link Option_MUNGLIST} option, specifies the
name of a task whose allocations should be dumped. The TASK option works,
however, only if MuGuardianAngel has been run with the
@{"NAMETAG" link Option_NAMETAG} before.


If used during startup in conjunction with @{"SNOOP" link Option_SNOOP},
this is the name of the task whose memory allocations and releases should be
dumped over the serial line.

@ENDNODE
@NODE Option_WAIT "Option: WAIT"
WAIT/S

If this is set, a task causing a MuGuardianAngel hit will be suspended. It
will run into a

        Wait(SIGF_SINGLE);

where it could be captured by a debugger.

@ENDNODE
@NODE Option_SNOOP "Option: SNOOP"
SNOOP/S

Turns on memory snooping: Memory allocations and releases are printed over
the serial port. It is recommended that you do not snoop all allocations but
limit snooping by using the @{"MIN" link Option_MIN} and
@{"MAX" link Option_MAX} options to define a region of interest.
Furthermore, you may define the name of the task that should be snooped,
using the @{"TASK" link Option_TASK} option. If you do not use any of these
restrictions, your system will become *very* slow.

@ENDNODE
@NODE Option_MIN "Option: MIN"
MIN/K

Used to define a lower limit for @{"SNOOP" link Option_SNOOP} and
@{"MUNGLIST" link Option_MUNGLIST}. Memory allocations below this size will
not be snooped or dumped. MIN defaults to 0.


This option accepts numbers in hex notation as well, by placing a "0x" or
"$" in front of the number.

@ENDNODE
@NODE Option_MAX "Option: MAX"
MAX/K

Used to define an upper limit for @{"SNOOP" link Option_SNOOP} and
@{"MUNGLIST" link Option_MUNGLIST}. Memory allocations above this size will
not be snooped or dumped. MAX defaults to 0xffffffff.


This option accepts numbers in hex notation as well, by placing a "0x" or
"$" in front of the number.

@ENDNODE
@NODE Option_DEBUG "Option: DEBUG"
DEBUG/S

If this is set, MuGuardianAngel will run the system debugger in case a
task hits. Register a0 will contain the return PC of the program, register
a1 the description of the failure as C style string. MuGuardianAngel loads
the registers and runs into a


        jsr Debug(a6)


to call the system debugger. This is by default either the RomWack for
releases V38 and below, or SAD for V39 and above.


@{B}IMPORTANT:@{UB} It is highly recommended that you install a system
monitor like COP before trying to use this option.

@ENDNODE
@NODE Option_SHOWFAIL "Option: SHOWFAIL"
SHOWFAIL/S

Tells MuGuardianAngel to treat failed memory allocations as errors and
to dump them as "hits". Memory flushes are *NOT* considered to be failed
allocations.

@ENDNODE
@NODE Option_SHOWSTACK "Option: SHOWSTACK"
SHOWSTACK/S

In case of a hit, MuGuardianAngel is told to dump
@{"STACKLINES" link Option_STACKLINES} of the user stack of the calling
program, provided the stack pointer is available.


This option will not do anything if the @{"TINY" link Option_TINY} output
mode is selected.


@ENDNODE
@NODE Option_SHOWPC "Option: SHOWPC"
SHOWPC/S

In case of a hit, MuGuardianAngel dumps the memory around the return PC of
the faulty call if available. This can be used to identify part of the
code that was responsible for the hit.


This option will not do anything if the @{"TINY" link Option_TINY} output
mode is selected.

@ENDNODE
@NODE Option_SHOWHUNK "Option: SHOWHUNK"
SHOWHUNK/S:

Tell MuGuardianAngel to try to identify the hunk, hunk offset and name of
the program that caused the hit.

This option requires the SegTracker running or it will do nothing.

@ENDNODE
@NODE Option_STACKLINES "Option: STACKLINES"
STACKLINES/K/N

The number of stack lines to dump if the
@{"SHOWSTACK" link Option_SHOWSTACK} is used. Each stack line consists of 16
bytes, and the number of lines defaults to two.

This option does nothing if either the @{"TINY" link Option_TINY} output
mode is selected, the stack pointer is not available or the
@{"SHOWSTACK" link Option_SHOWSTACK} option is not used.

@ENDNODE
@NODE Option_NAMETAG "Option: NAMETAG"
NAMETAG/S

Tells MuGuardianAngel to keep the name of the allocating task as well. This
option requires more memory, but is required to show the allocating task
in the @{"MUNGLIST" link Option_MUNGLIST}, and to enable the
@{"TASK" link Option_TASK} option for this list.


MuGuardianAngel will also make use of the name tag in case of a faulty
FreeMem() to dump the name of allocator of the memory block - note that this
need not to be identically.


@ENDNODE
@NODE Option_DATESTAMP "Option: DATESTAMP"
DATESTAMP=TIMESTAMP/S

This makes MuGuardianAngel output a date and time with each hit.  Due to
the nature of the way MuGuardianAngel must work, the time can not be read
during the hit itself so the time output will be the last time value the
main MuGuardianAngel task set up. MuGuardianAngel will update this value
every second as to try to not use any real CPU time. The time displayed in
the hit will thus be exact. (Assuming the system clock is correct.) The date
is output before anything from the hit other than the optional introduction
string.

@ENDNODE
@NODE Option_STACKSNOOP "Option: STACKSNOOP"
STACKSNOOP/S

Turns on periodic checks for stack overflow and underflow. MuGuardianAngel
checks then in each vertical blank the system tasks for out-of-range stack
pointers. Due to the way how this is done, no fault PC nor a stack dump is
available.

Moreover, it has been found that some tasks switch their stack without using
the recommended system function StackSwitch(), making this option more or
less unreliable and un-useful. Especially, the "SetENV" command as well as
the "FastFilingSystem" break these rules and will therefore cause a lot of
hits if this option is turned on.


For these reasons, just leave it off.


@{B}Note:@{UB}

Starting with release 40.28, MuGuardianAngel runs periodic stack checking
regardless of the STACKSNOOP option. It will, however, only report "nearly
out of stack" warnings unless STACKSNOOP is active.


If you REALLY REALLY want to turn them off completely, use the
@{"NOSTACKWARN" link Option_NOSTACKWARN} option.


@ENDNODE
@NODE Option_CONSISTENCY "Option: CONSISTENCY"
CON=CONSISTENCY/S

Turns on periodic consistency checks of the memory lists.

If this option is used, MuGuardianAngel will check the system memory lists
each vertical blank for

@{CODE}
- correct number of free bytes,
- well sorted memory chunks,
- out of range memory chunks
- misaligned memory chunks
@{BODY}

This may take quite a lot of CPU time, especially on "low-end" machines.


MuGuardianAngel is unfortunately not able to find the name of the task that
possibly caused the mess in these lists, nor does it anything to fix the
lists. If you see a hit from this option, you should better reboot soon.

@ENDNODE
@NODE Option_PRESIZE "Option: PRESIZE"
PRESIZE/K

Set the size of the front "mung wall" in bytes.

This wall around the memory block is allocated additionally to the memory
requested by the caller. It is then filled with a pre-defined pattern - see
the @{"FILLCHAR" link Option_FILLCHAR} option. Typical "out of range"
conditions will (hopefully) only damage the wall and nothing else.


On a FreeMem(), MuGuardianAngel checks the wall for this pattern
and "hits" in case it was overwritten by the program.


The size of the front wall defaults to 32 bytes, it can be enlarged or made
smaller by this option, but the size passed in is always rounded to the next
larger number divisible by eight.


This option accepts hex numbers as well, provided they are given in C or
assembler notation with leading "0x" or "$", respectively.

@ENDNODE
@NODE Option_POSTSIZE "Option: POSTSIZE"
POSTSIZE/K

Set the size of the rear "mung wall" in bytes.

This wall around the memory block is allocated additionally to the memory
requested by the caller. It is then filled with a pre-defined pattern - see
the @{"FILLCHAR" link Option_FILLCHAR} option. Typical "out of range"
conditions will (hopefully) only damage the wall and nothing else.


On a FreeMem(), MuGuardianAngel checks the wall for this pattern
and "hits" in case it was overwritten by the program.


The size of the rear wall defaults to 32 bytes, it can be enlarged or made
smaller by this option, but the size passed in is always rounded to the next
larger number divisible by eight.


This option accepts hex numbers as well, provided they are given in C or
assembler notation with leading "0x" or "$", respectively.

@ENDNODE
@NODE Option_PROTECTPOST "Option: PROTECTPOST"
PROTECTPOST/S

Enables a more critical memory allocation technique that will enlarge the
propability that out-of-bounds accesses will be detected.


If this option is enabled, MuGuardianAngel will align allocations such that
the end of the requested memory block is aligned to a MMU page such that the
following page can be access protected. Hence, out-of-bounds array accesses
are more likely detectable. This option should be combined with
@{"POSTSIZE=0" link Option_POSTSIZE} to forbid MuGuardianAngel allocation a
rear mungwall guard.


The side effect of this option is that the memory fragmentation will be
huge. Expect that even moderate program usage from the workbench will
require a minimum of 32MB, if not 64MB to make this option effective as if
MuGuardianAngel cannot allocate memory in an aligned fashion, it will fall
back to the default method. Your memory will look like a "swiss cheese" in
any case with this option turned on as the 68040 or 68060 MMUs require
allocations to be rounded up to at least 8K.


This option can be combined with the @{"TASK" link Option_TASK} command line
option to restrict the critical memory allocation scheme to a task of the
specified name. However, as other tasks allocate then memory in a
non-aligned fashion, their memory blocks may come near memory blocks of the
selected client and may therefore disable effective access protection.

@ENDNODE
@NODE Option_FILLCHAR "Option: FILLCHAR"
FILLCHAR/K

Selects the fill pattern for the "mung wall".


This wall around the memory block is allocated additionally to the memory
requested by the caller. It is then filled with a pre-defined byte value,
setup by this option. Typical "out of range" conditions will (hopefully)
only damage the wall and nothing else.


On a FreeMem(), MuGuardianAngel checks the wall for this pattern
and "hits" in case it was overwritten by the program.


This option accepts hex numbers as well, provided they are given in C or
assembler notation with leading "0x" or "$", respectively.


This option defaults to "-1" which will choose the "rolling wall":
MuGuardianAngel will change the wall for each allocation. Each other value
is used directly as fill pattern.

@ENDNODE
@NODE Option_LED "Option: LED"
LED/K/N


This option lets you specify the speed at which the LED will be toggled for
each MuGuardianAngel hit. The default is 0 which means that the LED will not
be touched. Using a larger value will make the flash take longer (such that
it can be noticed when doing I/O models other than the default serial
output) The time that the flash will take is a bit more than 1.3
microseconds times the number. So 1000 will be a bit more than 1.3
milliseconds. (Or 1000000 is a bit more than 1.3 seconds.)

@ENDNODE
@NODE Option_INTRO "Option: INTRO"
INTRO/K


This optional introduction string will be output at the start of every
hit. For example: INTRO="*NBad Program!" The default is no string.

@ENDNODE
@NODE Option_DISABLEBELL "Option: DISABLEBELL"
DISABLEBELL/S


Disables printing of the ASCII bell (BEL 0x07) that beeps the display on
external terminals or on Sushi output.

@ENDNODE
@NODE Option_TINY "Option: TINY"
TINY/S


This tells MuGuardianAngel to output a minimal hit.  The output is basically the
first line of the hit.

@ENDNODE
@NODE Option_AREGCHECK "Option: AREGCHECK"
AREGCHECK/S


This option tells MuGuardianAngel that you wish all of the values in the
Address Registers checked via "SegTracker", much like
@{"STACKCHECK" link Option_STACKCHECK}.

@ENDNODE
@NODE Option_DREGCHECK "Option: DREGCHECK"
DREGCHECK/S


This option tells MuGuardianAngel that you wish all of the values in
the Data Registers checked via "SegTracker", much like
@{"STACKCHECK" link Option_STACKCHECK}.

@ENDNODE
@NODE Option_STACKCHECK "Option: STACKCHECK"
STACKCHECK/S


This option tells MuGuardianAngel that you wish all of the long words
displayed in the stack to be checked against the global seglists via
"SegTracker". This will tell you what seglist various return addresses are
on the stack. If you are not displaying stack information in the hit or
MuGuardianAngel is not able to provide stack information, then STACKCHECK
will have nothing to check. If you are displaying stack information, then
each long word will be check and only those which are in one of the tracked
seglists will be displayed in a "SegTracker" line. The output will show the
PC address first and then work its way back on the stack such that you can
read it from bottom up as the order of calling or from top down as the
stack-frame back-trace.

@ENDNODE
@NODE Option_TOMUFORCE "Option: TOMUFORCE"
TOMUFORCE/S


This will merge the MuGuardianAngel output with the MuForce output stream.
If, for example, the MuForce output goes to a console window, the
MuGuardianAngel hits will show up in the same window.


If this option is not given, MuGuardianAngel dumps its hits over the serial
port. A tool like Sushi or Sashimi must then be used to redirect this
stream to a console window.

@ENDNODE
@NODE Option_DISPC "Option: DISPC"
DISPC/S


Enables disassembly of the code around the fault, which is most useful
for debugging and for having an immediate impression what the bug might
be.

This option requires the disassembler.library which is included in the
distribution.

@ENDNODE
@NODE Option_DISRANGE "Option: DISRANGE"
DISRANGE/K/N


Specifies the approximate number of bytes to disassemble around the fault if
the @{"DISPC" link Option_DISPC} option is turned on. This number is by
default 32, i.e. MuGuardianAngel will disassemble at least 32 bytes ahead
and below of the fault.

@ENDNODE
@NODE Option_NOMMU "Option: NOMMU"
NOMMU/S


Tells MuGuardianAngel not to use the MMU magic for protection of
non-allocated memory. This option is basically here as workaround for
questionable software that hacks on the MMU itself and therefore conflicts
with MuGuardianAngel. Note that using this option heavely degrades
MuGuardianAngel to "MungWall" as it will no longer be able to detect at
least some "out of bounds" accesses. This option shouldn't be used unless
it really can't make to work otherwise.

@ENDNODE
@NODE Option_ALLOWREUSE "Option: ALLOWREUSE"
ALLOWREUSE/S


Makes MuGuardianAngel a bit less picky about memory accesses. Without this
option, MuGuardianAngel will mark released memory as non-available
immediately, unless the calling task was in Forbid() or Disable() state. If
this option is found, MuGuardianAngel will leave this step to its supervisor
task and will, hence, delay this operation to the next task switch. It is
therefore recommended that you use this option together with
@{"PRI=-1" link Option_PRI} to delay the task switches as well.


Note that this option @{B}is not required@{UB} to keep correctly written
software working. This option is a work-around to keep the system alive even
with partially broken software installed. It will reduce the ability of
MuGuardianAngel to detect software faults and should therefore be used only
in the case MuGuardianAngel can't be made to work otherwise.

@ENDNODE
@NODE Option_DUMPWALL "Option: DUMPWALL"
DUMPWALL/S


This option tells MuGuardianAngel to print the mung wall in case it
found a broken or modified @{"mung wall" link Hit_BrokenWall} or in
case the @{"free memory cookie" link Hit_Cookie} was found defective when
allocating memory.


The dump consists of an indicator "W:" or "C:" indicating whether the mung
wall or the cookie was broken, the address of the dump, and a memory dump in
hex and ASCII of the broken memory.


MuGuardianAngel dumps a broken mung wall completely, but in case the memory
cookie has been modified, only the modified range (or the first modified
range, to be precise) will be dumped to screen to keep the output short.


This option is most useful to get a hint who might have overwritten
this memory.

@ENDNODE
@NODE Option_NOSTACKWARN "Option: NOSTACKWARN"
NOSTACKWARN/S


Disables the warning messages MuGuardianAngel generates automatically when
one of its memory handling functions was called with too little stack space
left. MuGuardianAngel will still swap in an emergency stack in case this
happens, just the "nearly out of stack" warning will not be printed.


@{B}REMEMBER!@{UB} This option doesn't fix any bugs. In fact, it just
prevents that bugs - namely too small stacks - are reported. Hence, this
option downgrades MuGuardianAngel somewhat and shouldn't be used unless you
really, really know what these stack warnings are about, and why they are
generated, that'd you'd better go and fix them in time.


@ENDNODE
@NODE Option_MINSTACK "Option: MINSTACK"
MINSTACK/N


Defines the minimal stack size in bytes required to avoid a "nearly out of
stack" warning of MuGuardianAngel. However, due to the way how
MuGuardianAngel works, this can only @{B}increase@{UB} the build-in stack
warn limit since the MuGuardianAngel system routines require some amount of
stack themselves.


A little remark: MuGuardianAngel runs a stack check on two occasions: For
first, periodically every 50th of a second, scanning all available tasks.
Second, on entry of each of the patch functions. In the second case,
MuGuardianAngel will be able to print a return PC and to provide additional
information, whereas only the task name can be reported in the first case.


@ENDNODE
@NODE Option_WAITFORMUFORCE "Option: WAITFORMUFORCE"
WAITFORMUFORCE/S


Tells MuGuardianAngel to wait until MuForce starts up. This might avoid
problems on startup if MuForce or MuGuardianAngel are run almost
simultaneously.


If this option is included, MuGuardianAngel will wait at most one minute for
MuForce to appear.

@ENDNODE

@NODE Hit_Cookie "Hit: Clear memory cookie at .. was found defective"
@TOC Hits
Cause of the fault:


When allocating some memory, MuGuardianAngel found that the cookie
free memory is usually filled with is damaged. Hence, some program managed
to write to the free memory without causing a hit. This might happen because
MuGuardianAngel isn't able to mark all free memory as invalid due to the
page granularity of the MMU. Since it is not clear when and by whom this hit
happened, MuGuardianAngel will not be able to display any useful information
about it. No caller PC nor a stack dump is possible. The task finding this
hit is, however, not necessarily the task that made the mess. The
printed address is the address where the defective cookie was found.



How to fix this:


Tough! Try to increase the mung wall with the
@{"PRESIZE" link Option_PRESIZE} or @{"POSTSIZE" link Option_POSTSIZE} a bit
to get the mung wall hit instead of free memory. Try to reproduce this bug,
i.e. whether it happens if a specific program is in use. Try to step thru
the program until the hit happens, possibly watching parts of the free
memory. To get more detailed information about what was written into free
memory, and hence to get a hint of who overwrote this memory, specify the
@{"DUMPWALL" link Option_DumpWall} option on startup and investigate the
"C: " lines in the printout.

@ENDNODE
@NODE Hit_BadSize "Hit: Release of ..: alloc. length .. <> released length .."
@TOC Hits
Cause of the fault:


MuGuardianAngel found a FreeMem() or a FreePooled() of a memory block whose
size does not match the corresponding AllocMem() resp. AllocPooled(). Hence,
a program tried to release a memory block only partially, or tried to
release more memory than allocated.



How to fix this:


MuGuardianAngel will be able to show you the caller PC and task of the
FreeMem() as the PC of the corresponding AllocMem(). In case you need the
name of the allocating task as well, specify the
@{"NAMETAG" link Option_NAMETAG} option when starting MuGuardianAngel.

Check your program around the allocation and the memory release and
make sure you're passing the correct size, or you're really not
releasing the memory block you intended to release. Check for invalid
pointers as well.


@{B}NOTE:@{UB} In case you see a return PC somewhere in the layers.library,
make sure you haven't installed a patch "on top" of MuGuardianAngel. This
WON'T WORK! MuGuardianAngel has to know the right caller PC for a special
kludge to fix a design bug in the layers.library.


In case MuGuardianAngel detects this fault, it will not release the memory
at all to avoid further hits.

@ENDNODE
@NODE Hit_BadPool "Hit: Release of .. :allocation pool .. <> release pool .."
@TOC Hits
Cause of the fault:


MuGuardianAngel found a FreePooled() of a memory chunk which was allocated
from a different memory pool, or which wasn't allocated from a memory pool
at all. Alternatively, a memory chunk allocated with AllocPooled() was
tried to be released with FreeMem(). Non-pooled allocations/releases
correspond to the memory pool indicated by 00000000.



How to fix this:


MuGuardianAngel will be able to show you the caller PC and task of the
FreeMem() as the PC of the corresponding AllocMem() or AllocPooled(). In
case you need the name of the allocating task as well, specify the
@{"NAMETAG" link Option_NAMETAG} option when starting MuGuardianAngel.

Check the program for consistent use of memory pools, specifically, make
sure that you allocate memory for Os structures correctly. Some libraries or
functions will try to release allocated memory on their own, possibly
expecting the memory to be "public", or to be allocated with AllocMem()
instead being taken from a pool.


@{B}NOTE:@{UB} In case MuGuardianAngel detects this fault, it will not
release the memory at all to avoid further hits.

@ENDNODE
@NODE Hit_BrokenWall "Hit: Front/Rear Mung-wall at .. is damaged"
@TOC Hits
Cause of the fault:


On the FreeMem() of a memory chunk, MuGuardianAngel found the mung wall of
the memory chunk defective. The number printed in the header is the memory
block whose mung wall was found broken. The hit could either state that the
"front" or the "rear" wall is broken. In first case, memory in front of the
allocated block was overwritten, in the latter case memory beyond the limit
was modified.



How to fix this:


This fault is typical for "out of range" accesses. Most likely, you
allocated "too little" memory to hold an array or a structure, or a C string
overrun the buffer. Remember that an array like


        int i[5]


will contain of the FIVE elements i[0] to i[4] and not i[1] to i[5]. Check
the Os documentation, especially the BUGS section of the autodocs, some
functions require a larger buffer than you might think. Check your strings
always for their size - a character array of 10 items can only hold strings
of nine character length. Check strcpy() for overruns, this function does
not check sizes at all.


To get more detailed information about what was written into the mung wall,
and hence to get a hint of who overwrote this memory, specify the
@{"DUMPWALL" link Option_DumpWall} option on startup.

@ENDNODE
@NODE Hit_InvalidFreeMem "Hit: MemHeader of chunk .. is not available"
@TOC Hits
Cause of the fault:


A program tried to release a memory block of a location that is nowhere in
the memory lists of exec.


How to fix this:


This ranges from easy to tough. Easiest possible cause is passing an invalid
pointer to FreeMem(). In this case, check pointers for correctness, set
unused pointers to NULL as soon as you don't need them anymore. Possibly,
the pointer for an object was pointing somehow in the "wilderness".


Another reason for this fault could be that a second program damaged the
exec memory list. In this case, restart MuGuardianAngel with the
@{"CONSISTENCY" link Option_CONSISTENCY} option to enable the periodic
memory check. As soon as a program messes with the exec memory lists, you'll
see a hit. Unfortunately, MuGuardianAngel won't be able to tell you the task
or the instruction that caused the mess, but you might be able to find the
problem by stepping thru the program that was running at the time the fault
appeared.


If this is the cause of the problem, the task mentioned in the
MuGuardianAngel hit is not necessarily the task causing the problem.

@ENDNODE
@NODE Hit_FreeTwice "Hit: Memory at .. released twice"
@TOC Hits
Cause of the fault:


The calling program tried to release a memory block that has been released
already before.



How to fix this:


Check the FreeMem() that caused the problem: You passed in a pointer to
something you already released before. As soon as you release an object,
try to set all pointers to this object to NULL to avoid this situation.

@ENDNODE
@NODE Hit_WithinChunk "Hit: Invalid FreeMem of memory at .."
@TOC Hits
Cause of the fault:

MuGuardianAngel found that the memory chunk that is to be released is
already partially, but not completely released. Parts of it have been found
in the exec free list.



How to fix this:


This hit means in most cases that you passed an invalid pointer to
FreeMem(), or the pointer to something that has been already released
before. This specific error happens then because a second program allocated
already parts of the object you released before, and you're now trying to
release again. As a rule of thumb, set all pointers to objects to NULL as
soon as you release them, this helps to detect the problem in most cases.

@ENDNODE
@NODE Hit_FreeMisMatch "Hit: Mem header ..: free counter .. <> .. in chunks"
@TOC Hits
Cause of the fault:



During a consistency check, MuGuardianAngel found that the number of free
bytes noted in the memory header whose address is printed in the hit is not
the same as the number of free bytes in the chunk list of this header.
The number left to the "<>" is the number of bytes as indicated by the
memory header, whereas the right hand side is the number of bytes which
are really available in the memory chunks.



How to fix this:


Tough. This means most likely that either the exec memory header was
damaged, or the chunk list is broken. In the first case, a program used an
illegal pointer that pointed "by accident" into the memory header. In the
second case a memory chunk could have been damaged because a program tried
to access it after it has been released. Typically, the chunk linkage
pointer MC_NEXT is set to NULL, terminating the chunk list before its "true"
end. This hit is typical for pointers that went mad or access of released
memory. In most cases, the program detecting this problem is NOT the program
responsible for the fault. Try to enable the
@{"CONSISTENCY" link Option_CONSISTENCY} option to check the memory
periodically and try to reproduce the problem.

The task shown in the MuGuardianAngel hit is not necessarily the task
causing the problem.

@ENDNODE
@NODE Hit_NullSized "Hit: Null-sized allocation, ignored"
@TOC Hits
Cause of the fault:

A program called AllocMem() with the size parameter set to zero.
MuGuardianAngel did not perform any allocation at all and passed a NULL
pointer as result.


How to fix this:

This bug happens typically if you want to allocate a dynamically sized
object you don't need in this specific situation. It is in most cases enough
to check for the NULL-sized case explicitly in your program and to fill in a
NULL pointer by hand. Possibly, you failed to calculate the size of an
object correctly.

@ENDNODE
@NODE Hit_FreeNULL "Hit: FreeMem of NULL pointer attempted, ignored"
@TOC Hits
Cause of the fault:


FreeMem() was called with a NULL pointer as memory argument. MuGuardianAngel
ignored the attempt completely and did nothing.



How to fix this:

In most cases, an explicit check for NULL in your program should be enough
to fix it - you're trying to release an object which does not, or no longer,
exist, possibly because an allocation failed somewhere above. In this case,
add a check for NULL behind corresponding the AllocMem().


@ENDNODE
@NODE Hit_MisFree "Hit: Misaligned release of .., size .. performed"
@TOC Hits
Cause of the fault:


MuGuardianAngel found that a misaligned pointer was passed into FreeMem() or
FreePooled(). Memory blocks are aligned to eight-byte boundaries, and so
should be the pointer passed in.



How to fix this:


This hit happens most likely because you passed an illegal and
invalid pointer to FreeMem(), possibly reading it from an object that does
no longer exist or that was partially overwritten by faulty code. Try to
single-step your code around the fault PC to see were the pointer was taken
from.

Another cause of this fault could be - even though this is unlikely - that
you allocated non-aligned memory with AllocAbs(). In that case, it is
CORRECT to pass the non-aligned pointer back to FreeMem(), and the hit
should be ignored. Check the @{"developer information" link Develop} for
details about this special case.

@ENDNODE
@NODE Hit_AllocFailed "Hit: Allocation of .. bytes failed"
@TOC Hits
Cause of the fault:


This hit shows only up if you told MuGuardianAngel with the
@{"SHOWFAIL" link Option_SHOWFAIL} to do so. It means that a memory
allocation by AllocMem() or AllocPooled() could not performed because either
not enough memory is available, or the requested type of memory is not
available.



How to fix this:


This is not really a hit, just a warning. The calling program will be
informed about the out-of-memory condition. However, it *might* mean that
the system run out of memory because your code never released the memory it
allocated before. In this case, restart MuGuardianAngel with the
@{"NAMETAG" link Option_NAMETAG} option, give the name of your task as
argument to @{"TASK" link Option_TASK} and enable snooping with
@{"SNOOP" link Option_SNOOP}. Possibly, specify @{"MIN" link Option_MIN} and
@{"MAX" link Option_MAX} to show only allocations and memory releases of
certain sizes.

Now type "avail flush" in the shell and start your program. Watch the output
carefully: A line starting with "A" is a memory allocation, the address of
the memory is found behind the "\@" sign. Each allocation should be matched
by one and exactly one line starting with "F", showing the corresponding
memory release. If you quit your program, type "avail flush again" and check
the output: Every "A" line should be matched by one "F" line. If you find
some "A"s without an "F", you failed to release some memory.

@ENDNODE
@NODE Hit_NearlyOut "Hit: Task ..: nearly out of stack"
@TOC Hits
Cause of the fault:


The MuGuardianAngel memory handling functions or the
@{"STACKSNOOP" link Option_STACKSNOOP} option found that the given task is
about to run out of stack space.



How to fix this:


It is usually enough to increase the stack size. However, if you see this
warning, it is most likely already too late.



@{B}WARNING:@{UB} This warning message is actually generated in two
situations:

First, the continously running vertical blank handler of
MuGuardianAngel detected a near stack overflow. It will be most likely too
late to do anything against it if this happens.

Second, a program run into the memory handling functions of MuGuardianAngel
with a nearly overrun stack. MuGuardianAngel will be able to give you
detailed stack information only in the latter case, though. In this specific
case, MuGuardianAngel will provide an "emergency stack" to aid the task and
to allow it to run on without further problems. This situation will
generate a warning message, regardless of whether
@{"STACKSNOOP" link Option_STACKSNOOP} was activated or not.


In any case, you should note that MuGuardianAngel does not check the stack
continuously. Therefore, MuGuardianAngel might easily overlook an
out-of-stack condition. Moreover, some tasks switch the stack without
informing the system correctly about this step, causing this hit without any
danger. The "FastFilingSystem" is one example. Therefore, the
@{"STACKSNOOP" link Option_STACKSNOOP} option is not recommended because it
might print a lot of "bogus" warnings.

@ENDNODE
@NODE Hit_Overflow "Hit: Task ..: stack overflow"
@TOC Hits
Cause of the fault:


The @{"STACKSNOOP" link Option_STACKSNOOP} option found that the given task
run out of stack space.



How to fix this:


It is usually enough to increase the stack size. However, if you see this
warning, it is already too late and the task overwrote innocent memory.
MuGuardianAngel will not be able to help you, tough luck!


This warning is generated for one of two situations: Either, the
MuGuardianAngel vertical blank handler detected an overrun stack on its
duty. Or, the memory handling functions detected the problem.
MuGuardianAngel will only be able to print detailed stack information in the
latter case.


@{B}WARNING:@{UB} The @{"STACKSNOOP" link Option_STACKSNOOP} does not check
the stack continuously, it is only watched every vertical blank and on
memory allocations and releases. Therefore, MuGuardianAngel might easily
overlook an out-of-stack condition. Moreover, some tasks switch stack
without informing the system correctly about this step, causing this hit
without any danger. The "FastFilingSystem" is one example. Therefore,
STACKSNOOPing is not recommended.

@ENDNODE
@NODE Hit_Underflow "Hit: Task ..: stack underflow"
@TOC Hits
Cause of the fault:


The @{"STACKSNOOP" link Option_STACKSNOOP} option found a task under-running
its stack space, i.e. it pulled more data from its stack than was available.



How to fix this:


This is a fatal error condition, but see below for the most common reason
for this hit. In case this is a true under-run, your code went crazy and
jumped into the "wilderness". It's best to step thru the problematic part
with a debugger and see what happens.


This warning is generated for one of two situations: Either, the
MuGuardianAngel vertical blank handler detected an underrun stack at its
duty. Or, the memory handling functions detected the problem.
MuGuardianAngel will only be able to print detailed stack information in the
latter case.


@{B}WARNING:@{UB} The @{"STACKSNOOP" link Option_STACKSNOOP} does not check
the stack continuously, it is only watched every vertical blank and on
memory allocations and releases. Therefore, MuGuardianAngel might easily
overlook an out-of-stack condition. Moreover, some tasks switch stack
without informing the system correctly about this step, causing this hit
without any danger. The "FastFilingSystem" is one example. Therefore,
STACKSNOOPing is not recommended.

@ENDNODE
@NODE Hit_InvMemList "Hit: Invalid memory list"
@TOC Hits
Cause of the fault:


During a consistency check, MuGuardianAngel found the exec memory list in a
desolate state. If you don't see a complete crash after this, you're lucky!


How to fix this:


Though! This hit happens only if a faulty program pokes into ExecBase and
hits the memory list. MuGuardianAngel will not be able to give you the name
of the task nor the PC of the faulty code. You're on your own here! Try to
reproduce the bug, using a debugger.


MuGuardianAngel is not able to give you the name of the task, nor the return
PC nor a stack dump if this problem shows up.

@ENDNODE
@NODE Hit_BadType "Hit: Mem header ..: node type is not NT_MEMORY"
@TOC Hits
Cause of the fault:


MuGuardianAngel found that the given memory header in the exec free memory
list is not of the correct type. Even though the node type is ignored
by the memory handling functions, this means that something is wrong in your
system.



How to fix this:


Though! Either you're using some utility that hacks the exec free memory
list and adds memory without setting the node type correctly, or some
program went mad and poked into the exec free list. In the last case, it
might be hard to identify the program because MuGuardianAngel can't give
you the return PC nor the faulty task. Try to reproduce the bug and... good
luck!


MuGuardianAngel is not able to give you the name of the task, nor the return
PC nor a stack dump if this problem shows up.

@ENDNODE
@NODE Hit_BadHeader "Hit: Mem header ..: lower is larger than upper"
@TOC Hits
Cause of the fault:


MuGuardianAngel found a memory header in the exec free memory list whose
lower address is larger than its upper end address. Hence, this header is
messed up. If you don't see a total crash after this hit you're lucky and
should take the chance to reboot before worse happens.



How to fix this:


Though! Looks like some program messed with the exec free list, possibly by
a pointer into the "wilderness". MuGuardianAngel can't help you much here
because it doesn't know the return PC nor the task the caused the mess.
Try to reproduce the bug and... good luck!


MuGuardianAngel is not able to give you the name of the task, nor the return
PC nor a stack dump if this problem shows up.

@ENDNODE
@NODE Hit_BadChunk "Hit: Mem header ..: chunk .. <lower or >upper"
@TOC Hits
Cause of the fault:


MuGuardianAngel found a memory chunk in a memory list that doesn't belong
there. Its address is either lower than the lower bound of the memory list,
or higher than the end address of the list.



How to fix this:


Though! Looks like some program messed with the exec free list, possibly by
a pointer into the "wilderness". MuGuardianAngel can't help you much here
because it doesn't know the return PC nor the task the caused the mess.
Try to reproduce the bug and... good luck!


MuGuardianAngel is not able to give you the name of the task, nor the return
PC nor a stack dump if this problem shows up.

@ENDNODE
@NODE Hit_Unsorted "Hit: Mem header ..: chunk .. order broken"
@TOC Hits
Cause of the fault:


MuGuardianAngel found the free memory list of the given memory header in a
desolate state, the chunks are no longer in their correct order and are no
longer sorted by address. Someone hits the memory list.



How to fix this:


Tough. A memory chunk could have been damaged because a program tried
to access it after it has been released. Typically, the chunk linkage
pointer MC_NEXT is set to some messy address, causing the illusion of
an unsorted but de-facto invalid list. This hit is typical for pointers that
went mad or access of released memory. MuGuardianAngel won't be able to
give you the name of the task that caused the mess, nor the return PC. Try
to reproduce the problem and... good luck. It might sometimes help to
increase the @{"POSTSIZE" link Option_POSTSIZE} and
the @{"PRESIZE" link Option_PRESIZE} to give a faulty task the chance to
hit the mung-wall instead of something more important.


MuGuardianAngel is not able to give you the name of the task, nor the return
PC nor a stack dump if this problem shows up.

@ENDNODE
@NODE Hit_MisChunk "Hit: Mem header ..: chunk after .. misaligned"
@TOC Hits
Cause of the fault:


MuGuardianAngel found a memory chunk in the free memory list that is not
correctly aligned - and most likely invalid. Since the fault is usually
a bad pointer of the chunk in front of the "misaligned" chunk, not the
misaligned address itself but the chunk pointing to this address is
printed. If you don't see a total crash after this hit, you're lucky.
Take the chance and reboot!



How to fix this:


Tough. A memory chunk could have been damaged because a program tried
to access it after it has been released. This hit is typical for pointers
that went mad or access of released memory. MuGuardianAngel won't be able to
give you the name of the task that caused the mess, nor the return PC. Try
to reproduce the problem and... good luck. It might sometimes help to
increase the @{"POSTSIZE" link Option_POSTSIZE} and
the @{"PRESIZE" link Option_PRESIZE} to give a faulty task the chance to
hit the mung-wall instead of something more important.


MuGuardianAngel is not able to give you the name of the task, nor the return
PC nor a stack dump if this problem shows up.


@ENDNODE
@NODE Hit_PatchWarn "Hit: MuGuardianAngel patches have been overwritten"
@TOC Hits
Cause of the fault:


Some program installed its own patches on top of the MuGuardianAngel
installations. This means asking for trouble! The MuGuardianAngel patches
*MUST BE* topmost in the patch list or the layers.library kludge won't work
anymore, causing a lot of problems on window re-arrangement.


How to fix this:


Try to locate the program that installed the patches. Running a tool like
"SaferPatches REMEMBER" might help you here a lot in detecting the program.
MuGuardianAngel will not be able to give you this information yourself,
unfortunately.

@ENDNODE
@NODE Hit_IRQMode "Hit: .. called from interrupt or supervisor mode"
@TOC Hits
Cause of the fault:


Some program called the mentioned Os function - AllocMem(), FreeMem(),
AvailMem(), AllocAbs(), AllocPooled(), FreePooled(), CreatePool() or
DeletePool() from interrupt or supervisor code. Note that this is illegal.


How to fix this:


Try to find the program that installed the interrupt vectors calling the Os
function. This @{B}need not@{UB} to be the task that shows up in the hit
output. Remove the offending code or de-install the faulty software. Note
that only very few functions can be called from interrupt code at all, as
for example PutMsg() and Signal(). In case you need memory in an interrupt
handler, build a private memory management, allocate the memory from a task,
put it in a list, ready available for the interrupt and use Signal() to
tell the master task to allocate more memory in case the memory list is
nearly run out. Don't forget to "bracket" your memory management with
Disable() or any other method to avoid simultaneous access from the
interrupt and the master code.

@ENDNODE
@NODE Hit_InvCreate "Hit: CreatePool puddleSize .., thresSize .. invalid"
@TOC Hits
Cause of the fault:


The calling program tried to build a memory pool, but specified illegal
parameters for the puddleSize and thresSize arguments. MuGuardianAngel
will complain if either of them is null, or the threshold size is larger
than the puddle size.


How to fix this:


Check the source code around the lines where the memory pools are allocated
and correct the parameters.

@ENDNODE
@NODE Hit_CreateFailed "Hit: CreatePool failed"
@TOC Hits
Cause of the fault:


This hit shows only up if you told MuGuardianAngel with the
@{"SHOWFAIL" link Option_SHOWFAIL} to do so. It means that the system run
out of memory when trying to build a new memory pool.



How to fix this:


This is not really a hit, just a warning. The calling program will be
informed about the out-of-memory condition. However, it *might* mean that
the system run out of memory because your code never released the memory it
allocated before. In this case, restart MuGuardianAngel with the
@{"NAMETAG" link Option_NAMETAG} option, give the name of your task as
argument to @{"TASK" link Option_TASK} and enable snooping with
@{"SNOOP" link Option_SNOOP}. Possibly, specify @{"MIN" link Option_MIN} and
@{"MAX" link Option_MAX} to show only allocations and memory releases of
certain sizes.

Now type "avail flush" in the shell and start your program. Watch the output
carefully: A line starting with "A" is a memory allocation, the address of
the memory is found behind the "\@" sign. Each allocation should be matched
by one and exactly one line starting with "F", showing the corresponding
memory release. If you quit your program, type "avail flush again" and check
the output: Every "A" line should be matched by one "F" line. If you find
some "A"s without an "F", you failed to release some memory.

@ENDNODE
@NODE Hit_NULLPool "Hit: DeletePool of NULL pointer attempted, ignored"
@TOC Hits
Cause of the fault:


A program called DeletePool() with a NULL pool argument, hence tried to
delete a non-existent pool.


How to fix this:


Check the pool management of the code. Most likely, you forgot to check for
a NULL pointer, or tried to release memory pools before having tried to
allocate them.

@ENDNODE
@NODE Hit_NULLPoolAlloc "Hit: Alloc/FreePooled from NULL pool attempted"
@TOC Hits
Cause of the fault:


The code called AllocPooled() or FreePooled() with a NULL pool argument,
hence failed to supply a memory pool for pooled allocations.


How to fix this:


Check your pool management. Most likely, you failed to call CreatePool()
before trying a pooled allocation, or you forgot to check for a NULL result
code of CreatePool(). Another possibility might be that you already deleted
the pool and tried to access it afterwards. Note that the system will
already clean up all memory in the pool when DeletePool() is called, you do
not need to release all pooled memory manually - even though this is a
matter of good style to do so.

@ENDNODE
@NODE Hit_PoolGarbled "Hit: Memory pool .. garbled"
@TOC Hits
Cause of the fault:


A program called FreePooled() with a memory chunk that was most likely
allocated correctly from the memory pool that was passed in as argument to
FreePooled(), but MuGuardianAngel failed to find the puddle of the pool
the chunk was taken from.


How to fix this:


This ranges from easy to tough. Easiest possible cause is passing an invalid
pointer to FreePooled(), which, due to some coincidence looked reasonable
for the first sanity check MuGuardianAngel performed. In this case, check
pointers for correctness, set unused pointers to NULL as soon as you don't
need them anymore. Possibly, the pointer for an object was pointing somehow
in the "wilderness".


Another reason for this fault could be that a second program damaged the
puddle list of the pool. This is nearly impossible to check. Unfortunately,
MuGuardianAngel won't be able to tell you the task or the instruction that
caused the mess, but you might be able to find the problem by stepping thru
the program that was running at the time the fault appeared.


If this is the cause of the problem, the task mentioned in the
MuGuardianAngel hit is not necessarily the task causing the problem.

@ENDNODE

@NODE Output "Example MuGuardianAngel output"
An example MuGuardianAngel output:

@{CODE}
Bad program!
03-Jul-99  14:26:14
Mung-wall at 01083bc8 is damaged.
PC  : 0105bd6a  USP: 010d6434 ( )( )  Name: memorydevil
----> 0105bd6a - "memorydevil"  Hunk 0 Offset 00000032
PCa : 0105bd5a  Name: memorydevil
----> 0105bd5a - "memorydevil"  Hunk 0 Offset 00000022
By  : AllocMem(0000002a,00000001)
Data: 0000002a 00000000 00001000 0101b744 00000001 0041ac8b 0040f69f 0105bd34
Addr: 010d6430 01083bc8 0101a62c 0105bd34 010d6438 00f9feaa SysBase  --------
Stck: 00fa06d6 00001000 0101b2ac a3a3a3a3 a3a3a3a3 a3a3a3a3 a3a3a3a3 a3a3a3a3
Stck: a3a3a3a3 a3a3a3a3 a3a3a3a3 01f80000 00e94c58 010d646c 010d6470 010d6474
PC-8: 4eaeff76 4a806718 702a7201 4eaeff3a 4a80670c 22404229 ffff702a 4eaeff2e
PC *: 4e759595 95959595 95959595 95959595 95959595 95959595 95959595 95959595
0105bd5a :  4a80                       tst.l d0
0105bd5c :  670c                       beq.s $105bd6a
0105bd5e :  2240                       movea.l d0,a1
0105bd60 :  4229 ffff                  clr.b -$1(a1)
0105bd64 :  702a                       moveq.l #$2a,d0
0105bd66 :  4eae ff2e                  jsr -$d2(a6)
0105bd6a : *4e75                       rts
0105bd6c :  9595                       sub.l d2,(a5)
0105bd6e :  9595                       sub.l d2,(a5)
0105bd70 :  9595                       sub.l d2,(a5)
0105bd72 :  9595                       sub.l d2,(a5)
0105bd74 :  9595                       sub.l d2,(a5)
0105bd76 :  9595                       sub.l d2,(a5)
0105bd78 :  9595                       sub.l d2,(a5)
@{BODY}


Here is a breakdown of what these reports are saying:


The first line is a user-configurable intro string. It is empty by default
but can be setup with the @{"INTRO" link Option_INTRO} option.


The second line is the date stamp.


The third line is the cause for the fault. A
@{"detailed description" link Hits} about what
@{"this error message" link Hit_BrokenWall} means can be found in this
guide. It, too, gives you the address of the where the fault was detected.


The fourth line shows the program counter of the task that caused the hit,
the user stack pointer, two flags that indicate whether exec is currently in
"Forbid" or "Disable" state and the name of the task causing the hit. If
the state was "forbidden", the first bracket would show an "(F)". In
disable state, the second bracket would say "(D)". The shown PC is the so
called "return PC", i.e. where program flow will continue after execution of
the Os call. It is not the address of the subroutine call itself. Unlike
MungWall, this return PC is automatically the correct one, but it might well
be that the allocation or release is done as a side effect by some Os
function.


The next line is only available if the SegTracker was installed and
the @{"SHOWHUNK" link Option_SHOWHUNK} option was activated. They give
detailed information about the name of the segment, the hunk and the segment
offset of the return PC shown in the line above.



The seventh line is special: In case the fault happened in a memory release
function, i.e. FreeMem(), MuGuardianAngel will dump here the return PC of
the corresponding allocation call, if available. This is most useful to see
what was allocated and by whom. The name of the allocating task is shown as
well, but information is only available if MuGuardianAngel was run with the
@{"NAMETAG" link Option_NAMETAG} option enabled. If not, the task name will
be "????". It is possibly important to remember that the task allocating the
memory is *usually* the same task that releases the memory, but AmigaOs does
not enforce this.


The line below is again a SegTracker dump of the return PC above.


The next line is the Os call that was used to obtain the memory. This
is either an "AllocMem", an "AllocVec" or an "AllocPooled".


The next two lines contain the data and address register dumps from
when the access fault happened.  Note that A6 and A7 are not listed here.
A6 has always to be the base address of the exec library, or the program
would have crashed earlier. A7 is the stack pointer and is listed as USP: in
the line above.


Then come the lines of stack back-trace.  These lines show the data on the
stack. This dump is activated with the @{"SHOWSTACK" link Option_SHOWSTACK}
 option.


If "SegTracker" was installed before MuGuardianAngel, the "---->" lines
will display in which seglist the given addresses are in based on the
global tracking that "SegTracker" does. If no seglist match is found, no
lines will be displayed. One line will be displayed for each of the stack
longwords asked for (see the STACKCHECK option) and one line for the PC
address of the hit. The lines are in order: hit, first stack find, second stack
find, etc. This is useful for tracking down who called the routine that
caused the hit.


Next, optionally, comes the data around the program counter when the access
fault happened. It is enabled with the @{"SHOWPC" link Option_SHOWPC}
 option. The first line (PC-8:) is the 8 long-words before the program
counter. The second line starts at the program counter - the "return PC" and
goes for 8 long words.


The last paragraph is a disassembly of the user code calling an Os function.
The PC where program execution will continue is marked by an asterisk.
This IS NOT the PC of the faulty instruction that caused the fault - which
is usually not available. MuGuardianAngel is usually only able to detect
these faults when an appropriate Os function is called, which will return to
the code segment shown in the disassembly.

To make this output available, the disassembler.library must be installed
and the @{"DISPC" link Option_DISPC} option must have been selected.



Let's look at the output of the @{"SNOOP" link Option_SNOOP} option:

@{CODE}
A: # ssssssss \@ aaaaaaaa attr: tttttttt PC: pppppppp - MyTask
F: # ssssssss \@ aaaaaaaa                PC: pppppppp - MyTask
@{BODY}

The first letter on a line indicates whether the performed operation is an
allocation - "A" - or a memory release - "F". The hex number behind "#" is
the size of the allocation, the number of bytes the task requested or the
number of bytes it releases. The hex number behind "\@" is the address of
the memory block allocated or to be released.

On allocation, the "attr" field indicates the memory attributes, i.e. the
second argument to AllocMem(). The "PC" field is the return PC where program
flow will continue. It is *not* the PC where the Os call was performed. The
last field is the name of the task performing the operation.



See also the @{"Detail Example" link DetailExample} for more information.

@ENDNODE
@NODE DetailExample "Detail Example Hit"

Example "MuGuardianAngel" Hit:  Click on the field for explanation.

@{CODE}
@{"Bad Program!" link Output_Intro}
@{"24-May-99  12:53:02" link Output_DateStamp}
@{"Front mung-wall at 01083bc8 is damaged." link Output_Hit}
@{"PC  : 0105bd6a" link Output_PC}  @{"USP: 013edbbc " link Output_USP}@{"( )" link Output_Forbid}@{"( )" link Output_Disable}  @{"Name: MemoryDevil" link Output_ReleaseName}
@{"---->" link Output_Segtracker} @{"013e496a" link Output_SegtrackerAddress} - "@{"MemoryDevil" link Output_SegtrackerName}" @{"Hunk 0" link Output_SegtrackerHunk} @{"Offset 00000032" link Output_SegtrackerOffset}
@{"PCa : 0105bd5a" link Output_PCa}  @{"Name: MemoryDevil" link Output_AllocName}
@{"---->" link Output_Segtracker} @{"013e495a" link Output_SegtrackerAddress} - "@{"MemoryDevil" link Output_SegtrackerName}" @{"Hunk 0" link Output_SegtrackerHunk} @{"Offset 00000022" link Output_SegtrackerOffset}
@{"By  : AllocMem(0000002a,00000001)" link Output_By}
@{"Data:" link Output_Dataregs}@{"0000002a" link Output_D0}@{"00000000" link Output_D1}@{"00001000" link Output_D2}@{"0130fad4" link Output_D3}@{"00000001" link Output_D4}@{"004f90d7" link Output_D5}@{"004bce9f" link Output_D6}@{"013e4934" link Output_D7}
@{"Addr:" link Output_Addrregs}@{"013edbb8" link Output_A0}@{"013e2858" link Output_A1}@{"0101a62c" link Output_A2}@{"013e4934" link Output_A3}@{"013edbc0" link Output_A4}@{"00f9feaa" link Output_A5}@{"SysBase " link Output_A6}@{"--------" link Output_A7}
@{"Stck:" link Output_Stack}@{"00fa06d6" link Output_Stackword}@{"00001000" link Output_Stackword}@{"0130f634" link Output_Stackword}@{"adadadad" link Output_Stackword}@{"adadadad" link Output_Stackword}@{"adadadad" link Output_Stackword}@{"adadadad" link Output_Stackword}@{"adadadad" link Output_Stackword}
@{"Stck:" link Output_Stack}@{"adadadad" link Output_Stackword}@{"adadadad" link Output_Stackword}@{"adadadad" link Output_Stackword}@{"013f3a28" link Output_Stackword}@{"00005da0" link Output_Stackword}@{"013edbf4" link Output_Stackword}@{"013edbf8" link Output_Stackword}@{"013edbfc" link Output_Stackword}
@{"---->" link Output_Segtracker} @{"00fa06d6" link Output_SegtrackerAddress} - "@{"ROM - dos 40.3 (1.4.93)" link Output_SegtrackerName}" @{"Hunk 0" link Output_SegtrackerHunk} @{"Offset 00000b2e" link Output_SegtrackerOffset}
@{"PC-8:" link Output_ShowPC}@{"4eaeff76" link Output_PCM8}@{"4a806718" link Output_PCM7}@{"702a7201" link Output_PCM6}@{"4eaeff3a" link Output_PCM5}@{"4a80670c" link Output_PCM4}@{"22404229" link Output_PCM3}@{"ffff702a" link Output_PCM2}@{"4eaeff2e" link Output_PCM1}
@{"PC *:" link Output_ShowPC}@{"4e759595" link Output_PCP0}@{"95959595" link Output_PCP1}@{"95959595" link Output_PCP2}@{"9f9f9f9f" link Output_PCP3}@{"9f9f9f9f" link Output_PCP4}@{"9f9f9f9f" link Output_PCP5}@{"9f9f9f9f" link Output_PCP6}@{"9f9f9f9f" link Output_PCP7}
@{"0105bd5a :  4a80                       tst.l d0       " link DisLine}
@{"0105bd5c :  670c                       beq.s $105bd6a " link DisLine}
@{"0105bd5e :  2240                       movea.l d0,a1  " link DisLine}
@{"0105bd60 :  4229 ffff                  clr.b -$1(a1)  " link DisLine}
@{"0105bd64 :  702a                       moveq.l #$2a,d0" link DisLine}
@{"0105bd66 :  4eae ff2e                  jsr -$d2(a6)   " link DisLine}
@{"0105bd6a : *4e75                       rts            " link DisLinePC}
@{"0105bd6c :  9595                       sub.l d2,(a5)  " link DisLine}
@{"0105bd6e :  9595                       sub.l d2,(a5)  " link DisLine}
@{"0105bd70 :  9595                       sub.l d2,(a5)  " link DisLine}
@{"0105bd72 :  9595                       sub.l d2,(a5)  " link DisLine}
@{"0105bd74 :  9595                       sub.l d2,(a5)  " link DisLine}
@{"0105bd76 :  9595                       sub.l d2,(a5)  " link DisLine}
@{"0105bd78 :  9595                       sub.l d2,(a5)  " link DisLine}
@{"W: 013e2838 b2<>b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 ................" link WallDump}
@{"   013e2848     b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 b2 00 ................" link WallDump}
@{BODY}


Note that "MuGuardianAngel" hit output is very configurable.  The above example hit
was produced with the following options:

@{"SHOWSTACK" link Option_SHOWSTACK} @{"SHOWPC" link Option_SHOWPC}
 @{"SHOWHUNK" link Option_SHOWHUNK} @{"NAMETAG" link Option_NAMETAG}
 @{"DATESTAMP" link Option_DATESTAMP} @{"DUMPWALL" link Option_DUMPWALL}
 @{"INTRO=Bad_Program!" link Option_INTRO}
 @{"DISPC" link Option_DISPC} @{"DISRANGE=16" link Option_DISRANGE}

@ENDNODE
@NODE Output_Intro "Output: Intro string"

This is a user defined intro string that gets printed in front of every hit.
It is setup with the @{"INTRO" link Option_INTRO} option.

@ENDNODE
@NODE Output_DateStamp "Output: Date Stamp"

The date stamp field, if enabled with the
@{"DATESTAMP" link Option_Datestamp}, is at the start of the
"MuGuardianAngel" hit. The time is only exact to +/- 1 second.

@ENDNODE
@NODE Output_Hit "Output: Hit"

This field describes the type of the problem. In this example, the mung wall
of the memory block at 01347000 was overwritten, i.e. the program touched
memory out of the allocated range.


See also: @{"MuGuardianAngel error messages" link Hits} for a list of all
possible hits.

@ENDNODE
@NODE Output_PC "Output: Program Counter"

This field displays the program counter the code will return to as soon as
the Os call finishes. It is not the program counter of the instruction that
called the Os function.


Note that this PC need not to be in your program in case an Os function
allocates or releases memory. More useful information is then available thru
the @{"stack-dump" link Output_Stackword}.


On some hits, for example for a failed consistency check, MuGuardianAngel is
not able to provide this information. The program counter field will then
show up as "00000000".

@ENDNODE
@NODE Output_USP "Output: User stack pointer"

This field gives the contents of the user stack pointer before the Os
function was called. The additional data pushed onto the stack by the Os
function itself is not included.


On some hits, for example for a failed consistency check, MuGuardianAngel is
not able to provide this information. The stack pointer field will then
show up as "00000000".

@ENDNODE
@NODE Output_Forbid "Output: Forbid/Permit indicator"

This field contains status information of the exec system library. It will
say "(F)" if the task is in FORBID state, i.e. multitasking is disabled.

@ENDNODE
@NODE Output_Disable "Output: Disable/Enable indicator"

This field contains status information about the exec library. It will say
"(D)" if the task is in DISABLED state, i.e. interrupts - and hence
multitasking - is disabled.

@ENDNODE
@NODE Output_ReleaseName "Output: Task name"

This field is the name of the task that called the Os function, causing the
hit. In case the task was a CLI task, this will be the name of the CLI
module. MuGuardianAngel will always cut down the name to 34 characters, due
to space limitations.


In case the task name is invalid, MuGuardianAngel will print four question
marks here: "????".


Note, however, that this need not to be the task that was really
responsible for the problem. In some cases, it might only be the task
detecting the problem. More detailed information about this is in the
@{"list of all error messages" link Hits}.

@ENDNODE
@NODE Output_SegTracker "Output: SegTracker"

This symbol "---->" identifies a line produced via the
"SegTracker" utility.


This information is therefore only available if the "SegTracker" was started
before "MuGuardianAngel" was run.


See the "FindHit" documentation for details as to how to use this information.

@ENDNODE
@NODE Output_SegTrackerAddress "Output: SegTracker Address"

This is the address that the hunk/offset describes.  This is here such
that you can cross-reference it with a value on the stack, in a register,
or the program counter.  The hunk/offset on the same line are produced
when this address is processed via "SegTracker".


This information is therefore only available if the "SegTracker" was started
before "MuGuardianAngel" was run.


See the "FindHit" documentation for details as to how to use this information.

@ENDNODE
@NODE Output_SegTrackerName "Output: SegTracker Name"

This is the name of the file, as passed to LoadSeg, which was found to
be loaded around the address given, made available by the "SegTracker"
utility. This information is therefore only available if the "SegTracker"
was started before "MuGuardianAngel" was run.


See the "FindHit" documentation for details as to how
to use this information.

@ENDNODE
@NODE Output_SegTrackerHunk "Output: Hunk"

This is the hunk in the load file that was loaded around the
given address, made available by the "SegTracker"


This information is therefore only available if the "SegTracker" was started
before "MuGuardianAngel" was run.


See the "FindHit" documentation for details as to how
to use this information.



@ENDNODE
@NODE Output_SegTrackerOffset "Output: Offset"

This is the offset from the start of the hunk that this address is
at within the given load file. This information is therefore only available
if the "SegTracker" was started before "MuGuardianAngel" was run.


See the "FindHit" documentation for details as to how
to use this information.

@ENDNODE
@NODE Output_By "Output: Allocating Os Procedure"

This line presents the Os call, including the parameters, that was used to
allocate the memory. This is either an "AllocMem", an "AllocVec" or an
"AllocPooled".

@ENDNODE
@NODE Output_PCa "Output: Return PC of the allocating function"

This information is only available if a problem during a FreeMem()/FreeVec()
was detected. It displays the return PC of the corresponding memory
allocation function, i.e. the address of the code the allocating Os function
returned to at the time the memory was allocated.

@ENDNODE
@NODE Output_AllocName "Output: Name of the allocating task"

This information is only available if a problem during a FreeMem()/FreeVec()
was detected. It displays the name of the task that made the corresponding
allocation, if available. Note that this need not to be the same task as the
current task, making the deallocation.


If MuGuardianAngel cannot provide this name, this field will say "????". The
@{"NAMETAG" link Option_NAMETAG} option is required to enable this extended
information.

@ENDNODE
@NODE WallDump "Output: Dump of the mung-wall"

These two lines contain a print out of the mung wall or a broken memory
cookie. In the first case, as shown here, the lines are introduced by a
"W:", in case of a broken cookie, MuGuardianAngel will print a "C:" instead.

The next hex number is the address of the memory that is dumped.

The number in front of the unequal "<>" sign is the character the mung wall
should contain, all characters beyond show the current wall contents in hex
as well as in ASCII. MuGuardianAngel replaces every un-printable character
by a dot (".") here to avoid problems when printing this output.

As you see in this example, the last byte of the wall is damaged and is
"00" instead of "b2".


In case a memory cookie was found defective, MuGuardianAngel doesn't print
the full memory region, but only the damaged region. A valid memory cookie
is the address of the memory region plus four.

@ENDNODE
@NODE Output_DataRegs "Output: Data Register Dump"

This line contains a dump of the data registers right before the failing Os
function was called, if available. All parameters for the Os call will be
included in this list.


In some situations, for example for a failed consistency check,
MuGuardianAngel will not be able to provide this information.

@ENDNODE
@NODE Output_D0 "Output: D0 Register"

The D0 register of the 680x0 CPU.

See @{"Data:" link Output_DataRegs}

@ENDNODE
@NODE Output_D1 "Output: D1 Register"

The D1 register of the 680x0 CPU.

See @{"Data:" link Output_DataRegs}

@ENDNODE
@NODE Output_D2 "Output: D2 Register"

The D2 register of the 680x0 CPU.

See @{"Data:" link Output_DataRegs}

@ENDNODE
@NODE Output_D3 "Output: D3 Register"

The D3 register of the 680x0 CPU.

See @{"Data:" link Output_DataRegs}

@ENDNODE
@NODE Output_D4 "Output: D4 Register"

The D4 register of the 680x0 CPU.

See @{"Data:" link Output_DataRegs}

@ENDNODE
@NODE Output_D5 "Output: D5 Register"

The D5 register of the 680x0 CPU.

See @{"Data:" link Output_DataRegs}

@ENDNODE
@NODE Output_D6 "Output: D6 Register"

The D6 register of the 680x0 CPU.

See @{"Data:" link Output_DataRegs}

@ENDNODE
@NODE Output_D7 "Output: D7 Register"

The D7 register of the 680x0 CPU.

See @{"Data:" link Output_DataRegs}

@ENDNODE
@NODE Output_AddrRegs "Output: Address Register Dump"


This line contains a dump of the data registers right before the failing Os
function was called, if available. All parameters for the Os call will be
included in this list.


In some situations, for example for a failed consistency check,
MuGuardianAngel will not be able to provide this information.


Address register A7 is the @{"user stack pointer" link Output_USP} and
therefore available elsewhere. Register A6 is always a pointer to the
exec.library and therefore not included.

@ENDNODE
@NODE Output_A0 "Output: A0 Register"

The A0 register of the 680x0 CPU.

See @{"Addr:" link Output_AddrRegs}

@ENDNODE
@NODE Output_A1 "Output: A1 Register"

The A1 register of the 680x0 CPU.

See @{"Addr:" link Output_AddrRegs}

@ENDNODE
@NODE Output_A2 "Output: A2 Register"

The A2 register of the 680x0 CPU.

See @{"Addr:" link Output_AddrRegs}

@ENDNODE
@NODE Output_A3 "Output: A3 Register"

The A3 register of the 680x0 CPU.

See @{"Addr:" link Output_AddrRegs}

@ENDNODE
@NODE Output_A4 "Output: A4 Register"

The A4 register of the 680x0 CPU.

See @{"Addr:" link Output_AddrRegs}

@ENDNODE
@NODE Output_A5 "Output: A5 Register"

The A5 register of the 680x0 CPU.

See @{"Addr:" link Output_AddrRegs}

@ENDNODE
@NODE Output_A6 "Output: A6 Register"

The A6 register of the 680x0 CPU. Since this address register is fixed to
the base address of the exec.library for the Os functions that
MuGuardianAngel watches, it is not included in the dump.

See @{"Addr:" link Output_AddrRegs}

@ENDNODE
@NODE Output_A7 "Output: A7 Register"

The A7 register of the 680x0 CPU is always the user stack pointer. It is
shown in the USP field of the MuGuardianAngel hit and not included here.

See @{"Addr:" link Output_AddrRegs}

@ENDNODE
@NODE Output_Stack "Output: Stack Dump"

These lines contain stack dumps from the task that caused the
"MuGuardianAngel" hit. It can be used to figure out what the program
was doing and what routines called the current routine by looking at the
values on the stack.


This output is enabled with the @{"SHOWSTACK" link Option_SHOWSTACK} option,
but even if it is enabled, MuGuardianAngel will not be able to give a stack
dump in some situations. This happens, for example, if a memory consistency
check failed.

@ENDNODE
@NODE Output_StackWord "Output: Stack Word"

This is a longword on the stack of the task that caused the hit. Stack
dumping is enabled by the @{"SHOWSTACK" link Option_SHOWSTACK} option.


See @{"Stck:" link Output_Stack} for more details.

@ENDNODE
@NODE Output_ShowPC "Output: Show PC"

If the @{"SHOWPC" link Option_SHOWPC} option is turned on,
"MuGuardianAngel" will dump the 8 longwords before the return PC
and the 8 longwords starting at the PC. The return PC is the address of the
code the Os function will return to after completion, not the address of the
Os call itself.


This can be used to help debug programs by being able to look at the
code around the hit by disassembling it.

@ENDNODE
@NODE Output_PCM8 "Output: Show PC-$20"

This is the longword at the memory address (PC - $20)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCM7 "Output: Show PC-$1C"

This is the longword at the memory address (PC - $1C)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCM6 "Output: Show PC-$18"

This is the longword at the memory address (PC - $18)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCM5 "Output: Show PC-$14"

This is the longword at the memory address (PC - $14)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCM4 "Output: Show PC-$10"

This is the longword at the memory address (PC - $10)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCM3 "Output: Show PC-$0C"

This is the longword at the memory address (PC - $0c)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCM2 "Output: Show PC-$08"

This is the longword at the memory address (PC - $08)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCM1 "Output: Show PC-$04"

This is the longword at the memory address (PC - $04)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCP0 "Output: Show PC+$00"

This is the longword at the memory address (PC)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCP1 "Output: Show PC+$04"

This is the longword at the memory address (PC + $04)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCP2 "Output: Show PC+$08"

This is the longword at the memory address (PC + $08)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCP3 "Output: Show PC+$0C"

This is the longword at the memory address (PC + $0C)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCP4 "Output: Show PC+$10"

This is the longword at the memory address (PC + $10)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCP5 "Output: Show PC+$14"

This is the longword at the memory address (PC + $14)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCP6 "Output: Show PC+$18"

This is the longword at the memory address (PC + $18)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE Output_PCP7 "Output: Show PC+$1C"

This is the longword at the memory address (PC + $1C)
where PC is the @{"return PC" link Output_PC} of the failed Os call.

@ENDNODE
@NODE DisLine "Output: Disassembler output"

This line is generated by the disassembler, it presents the code in Motorola
opcode notation around the PC where the fault was detected.

@ENDNODE
@NODE DisLinePC "Output: Disassembler output with PC"

This line is the disassembly of the instruction where the fault was
detected. It is marked by an asterisk "*" in front of the opcodes. The
actual Os call that caused the MuGuardianAngel hit will be the instruction
immediately above this line.

@ENDNODE
@NODE INDEX "Index"
@{CODE}

        A...

        @{"Output: A0 Register" link OUTPUT_A0}
        @{"Output: A1 Register" link OUTPUT_A1}
        @{"Output: A2 Register" link OUTPUT_A2}
        @{"Output: A3 Register" link OUTPUT_A3}
        @{"Output: A4 Register" link OUTPUT_A4}
        @{"Output: A5 Register" link OUTPUT_A5}
        @{"Output: A6 Register" link OUTPUT_A6}
        @{"Output: A7 Register" link OUTPUT_A7}
        @{"Output: Address Register Dump" link OUTPUT_ADDRREGS}
        @{"Output: Allocating Os Procedure" link Output_By}
        @{"Hit: Allocation of .. bytes failed" link HIT_ALLOCFAILED}
        @{"Hit: Alloc/FreePooled from NULL pool attempted" link HIT_NULLPOOLALLOC}
        @{"Option: ALLOWREUSE" link Option_ALLOWREUSE}
        @{"Option: AREGCHECK" link OPTION_AREGCHECK}

        B...

        @{"Output: By : line (Allocating Os Procedure)" link Output_By}

        C...

        @{"Hit: Clear memory cookie at .. was found defective" link HIT_COOKIE}
        @{"Command line options and tooltypes" link CONFIG}
        @{"Option: CONSISTENCY" link OPTION_CONSISTENCY}
        @{"Correct memory handling: Avoiding hits" link DEVELOP}
        @{"Hit: CreatePool failed" link HIT_CREATEFAILED}
        @{"Hit: CreatePool puddleSize .., thresSize .. invalid" link HIT_INVCREATE}
        @{"Credits : Thank you goes to..." link CREDITS}

        D...

        @{"Output: D0 Register" link OUTPUT_D0}
        @{"Output: D1 Register" link OUTPUT_D1}
        @{"Output: D2 Register" link OUTPUT_D2}
        @{"Output: D3 Register" link OUTPUT_D3}
        @{"Output: D4 Register" link OUTPUT_D4}
        @{"Output: D5 Register" link OUTPUT_D5}
        @{"Output: D6 Register" link OUTPUT_D6}
        @{"Output: D7 Register" link OUTPUT_D7}
        @{"Output: Data Register Dump" link OUTPUT_DATAREGS}
        @{"Output: Date Stamp" link OUTPUT_DATESTAMP}
        @{"Option: DATESTAMP" link OPTION_DATESTAMP}
        @{"Option: DEBUG" link OPTION_DEBUG}
        @{"Hit: DeletePool of NULL pointer attempted, ignored" link Hit_NULLPool}
        @{"Detail Example Hit" link DETAILEXAMPLE}
        @{"Option: DISABLEBELL" link OPTION_DISABLEBELL}
        @{"Output: Disable/Enable indicator" link OUTPUT_DISABLE}
        @{"Output: Disassembler output" link DisLine}
        @{"Output: Disassembler output with PC" link DisLinePC}
        @{"Option: DISPC" link OPTION_DISPC}
        @{"Option: DISRANGE" link OPTION_DISRANGE}
        @{"Option: DREGCHECK" link OPTION_DREGCHECK}
        @{"Output: Dump of the mung wall" link WallDump}
        @{"Option: DUMPWALL" link OPTION_DUMPWALL}

        E...

        @{"MuGuardianAngel error messages" link HITS}
        @{"Example MuGuardianAngel output" link OUTPUT}

        F...

        @{"Option: FILLCHAR" link OPTION_FILLCHAR}
        @{"Hit: FreeMem of NULL pointer attempted, ignored" link HIT_FREENULL}
        @{"Output: Forbid/Permit indicator" link OUTPUT_FORBID}
        @{"Hit: Front mung-wall at .. is damaged" link HIT_BROKENWALL}


        H...

        @{"History" link HISTORY}
        @{"Output: Hit" link OUTPUT_HIT}
        @{"Hit: Release of ..: alloc. length .. <> released length .." link HIT_BADSIZE}
        @{"Hit: Release of ..: allocation pool .. <> release pool .." link HIT_BADPOOL}
        @{"Hit: Allocation of .. bytes failed" link HIT_ALLOCFAILED}
        @{"Hit: Alloc/FreePooled from NULL pool attempted" link HIT_NULLPOOLALLOC}
        @{"Hit: Clear memory cookie at .. was found defective" link HIT_COOKIE}
        @{"Hit: CreatePool puddleSize .., thresSize .. invalid" link HIT_INVCREATE}
        @{"Hit: CreatePool failed" link HIT_CREATEFAILED}
        @{"Hit: DeletePool of NULL pointer attempted, ignored" link Hit_NULLPool}
        @{"Hit: FreeMem of NULL pointer attempted, ignored" link HIT_FREENULL}
        @{"Hit: Invalid FreeMem of memory at .." link HIT_WITHINCHUNK}
        @{"Hit: Invalid memory list" link HIT_INVMEMLIST}
        @{"Hit: .. called from interrupt or supervisor mode" link HIT_IRQMODE}
        @{"Hit: Mem header ..: mem chunk .. <lower or >upper" link HIT_BADCHUNK}
        @{"Hit: Mem header ..: mem chunk after .. misaligned" link HIT_MISCHUNK}
        @{"Hit: Mem header ..: mem chunk .. order broken" link HIT_UNSORTED}
        @{"Hit: Mem header ..: mem lower is larger than upper" link HIT_BADHEADER}
        @{"Hit: MemHeader of chunk .. is not available" link HIT_INVALIDFREEMEM}
        @{"Hit: Mem header ..: free counter .. <> .. in chunks" link HIT_FREEMISMATCH}
        @{"Hit: Mem header ..: node type is not NT_MEMORY" link HIT_BADTYPE}
        @{"Hit: Memory pool .. garbled" link Hit_PoolGarbled}
        @{"Hit: Memory at .. released twice" link HIT_FREETWICE}
        @{"Hit: Misaligned release of .., size .. performed" link HIT_MISFREE}
        @{"Hit: MuGuardianAngel patches have been overwritten" link Hit_PatchWarn}
        @{"Hit: Mung-wall at .. is damaged" link HIT_BROKENWALL}
        @{"Hit: Task ..: nearly out of stack" link HIT_NEARLYOUT}
        @{"Hit: Null-sized allocation, ignored" link HIT_NULLSIZED}
        @{"Hit: Task ...: stack overflow" link HIT_OVERFLOW}
        @{"Hit: Task ...: stack underflow" link HIT_UNDERFLOW}
        @{"Output: Hunk" link OUTPUT_SEGTRACKERHUNK}

        I...

        @{"Index" link INDEX}
        @{"Installation of MuGuardianAngel" link INSTALL}
        @{"Option: INTRO" link OPTION_INTRO}
        @{"Output: Intro string" link OUTPUT_INTRO}
        @{"Hit: Invalid FreeMem of memory at .." link HIT_WITHINCHUNK}
        @{"Hit: Invalid memory list" link HIT_INVMEMLIST}
        @{"Hit: .. called from interrupt or supervisor mode" link HIT_IRQMODE}

        L...

        @{"Option: LED" link OPTION_LED}
        @{"The THOR-Software Licence" link LICENCE}

        M...

        @{"Option: MAX" link OPTION_MAX}
        @{"Hit: Mem header ..: chunk .. <lower or >upper" link HIT_BADCHUNK}
        @{"Hit: Mem header ..: chunk after .. misaligned" link HIT_MISCHUNK}
        @{"Hit: Mem header ..: chunk .. order broken" link HIT_UNSORTED}
        @{"Hit: Mem header ..: lower is larger than upper" link HIT_BADHEADER}
        @{"Hit: MemHeader of chunk .. is not available" link HIT_INVALIDFREEMEM}
        @{"Hit: Memory at .. released twice" link HIT_FREETWICE}
        @{"Hit: Mem header ..: free counter .. <> .. in chunks" link HIT_FREEMISMATCH}
        @{"Hit: Memory header ..: node type is not NT_MEMORY" link HIT_BADTYPE}
        @{"Hit: Memory pool .. garbled" link Hit_PoolGarbled}
        @{"Option: MIN" link OPTION_MIN}
        @{"Option: MINSTACK" link OPTION_MINSTACK}
        @{"Hit: Misaligned FreeMem of .., size .. performed" link HIT_MISFREE}
        @{"What's the MMU.library?" link MMUOVERVIEW}
        @{"MuGuardianAngel error messages" link HITS}
        @{"MuGuardianAngel restrictions" link RESTRICTIONS}
        @{"Hit: MuGuardianAngel patches have been overwritten" link Hit_PatchWarn}
        @{"Option: MUNGLIST" link OPTION_MUNGLIST}
        @{"Hit: Front/Rear mung-wall at .. is damaged" link HIT_BROKENWALL}

        N...

        @{"Output: Name of the allocating task" link OUTPUT_ALLOCNAME}
        @{"Option: NAMETAG" link OPTION_NAMETAG}
        @{"Hit: Task ..: nearly out of stack" link HIT_NEARLYOUT}
        @{"Option: NOMMU" link Option_NOMMU}
        @{"Option: NOSTACKWARN" link Option_NOSTACKWARN}
        @{"Hit: Null-sized allocation, ignored" link HIT_NULLSIZED}

        O...

        @{"Output: Offset" link OUTPUT_SEGTRACKEROFFSET}
        @{"Option: ALLOWREUSE" link Option_ALLOWREUSE}
        @{"Option: AREGCHECK" link OPTION_AREGCHECK}
        @{"Option: CONSISTENCY" link OPTION_CONSISTENCY}
        @{"Option: DATESTAMP" link OPTION_DATESTAMP}
        @{"Option: DEBUG" link OPTION_DEBUG}
        @{"Option: DISABLEBELL" link OPTION_DISABLEBELL}
        @{"Option: DISPC" link OPTION_DISPC}
        @{"Option: DISRANGE" link OPTION_DISRANGE}
        @{"Option: DREGCHECK" link OPTION_DREGCHECK}
        @{"Option: FILLCHAR" link OPTION_FILLCHAR}
        @{"Option: INTRO" link OPTION_INTRO}
        @{"Option: LED" link OPTION_LED}
        @{"Option: MAX" link OPTION_MAX}
        @{"Option: MIN" link OPTION_MIN}
        @{"Option: MINSTACK" link OPTION_MINSTACK}
        @{"Option: MUNGLIST" link OPTION_MUNGLIST}
        @{"Option: NAMETAG" link OPTION_NAMETAG}
        @{"Option: NOMMU" link Option_NOMMU}
        @{"Option: NOSTACKWARN" link Option_NOSTACKWARN}
        @{"Option: POSTSIZE" link OPTION_POSTSIZE}
        @{"Option: PRESIZE" link OPTION_PRESIZE}
        @{"Option: PRIORITY" link OPTION_PRI}
        @{"Option: PROTECTPOST" link OPTION_PROTECTPOST}
        @{"Option: QUIT" link OPTION_QUIT}
        @{"Option: SHOWFAIL" link OPTION_SHOWFAIL}
        @{"Option: SHOWHUNK" link OPTION_SHOWHUNK}
        @{"Option: SHOWPC" link OPTION_SHOWPC}
        @{"Option: SHOWSTACK" link OPTION_SHOWSTACK}
        @{"Option: SNOOP" link OPTION_SNOOP}
        @{"Option: STACKCHECK" link OPTION_STACKCHECK}
        @{"Option: STACKLINES" link OPTION_STACKLINES}
        @{"Option: STACKSNOOP" link OPTION_STACKSNOOP}
        @{"Option: TASK" link OPTION_TASK}
        @{"Option: TINY" link OPTION_TINY}
        @{"Option: TOMUFORCE" link OPTION_TOMUFORCE}
        @{"Option: WAIT" link OPTION_WAIT}
        @{"Option: WAITFORMUFORCE" link OPTION_WAITFORMUFORCE}
        @{"Output: A0 Register" link OUTPUT_A0}
        @{"Output: A1 Register" link OUTPUT_A1}
        @{"Output: A2 Register" link OUTPUT_A2}
        @{"Output: A3 Register" link OUTPUT_A3}
        @{"Output: A4 Register" link OUTPUT_A4}
        @{"Output: A5 Register" link OUTPUT_A5}
        @{"Output: A6 Register" link OUTPUT_A6}
        @{"Output: A7 Register" link OUTPUT_A7}
        @{"Output: Address Register Dump" link OUTPUT_ADDRREGS}
        @{"Output: D0 Register" link OUTPUT_D0}
        @{"Output: D1 Register" link OUTPUT_D1}
        @{"Output: D2 Register" link OUTPUT_D2}
        @{"Output: D3 Register" link OUTPUT_D3}
        @{"Output: D4 Register" link OUTPUT_D4}
        @{"Output: D5 Register" link OUTPUT_D5}
        @{"Output: D6 Register" link OUTPUT_D6}
        @{"Output: D7 Register" link OUTPUT_D7}
        @{"Output: Data Register Dump" link OUTPUT_DATAREGS}
        @{"Output: Date Stamp" link OUTPUT_DATESTAMP}
        @{"Output: Disable/Enable indicator" link OUTPUT_DISABLE}
        @{"Output: Disassembler output" link DisLine}
        @{"Output: Disassembler output with PC" link DisLinePC}
        @{"Output: Dump of the mung wall" link WallDump}
        @{"Output: Forbid/Permit indicator" link OUTPUT_FORBID}
        @{"Output: Hit" link OUTPUT_HIT}
        @{"Output: Hunk" link OUTPUT_SEGTRACKERHUNK}
        @{"Output: Intro string" link OUTPUT_INTRO}
        @{"Output: Name of the allocating task" link OUTPUT_ALLOCNAME}
        @{"Output: Offset" link OUTPUT_SEGTRACKEROFFSET}
        @{"Output: Program Counter" link OUTPUT_PC}
        @{"Output: Return PC of the allocating function" link OUTPUT_PCA}
        @{"Output: SegTracker" link OUTPUT_SEGTRACKER}
        @{"Output: SegTracker Address" link OUTPUT_SEGTRACKERADDRESS}
        @{"Output: SegTracker Name" link OUTPUT_SEGTRACKERNAME}
        @{"Output: Show PC" link OUTPUT_SHOWPC}
        @{"Output: Show PC+$00" link OUTPUT_PCP0}
        @{"Output: Show PC+$04" link OUTPUT_PCP1}
        @{"Output: Show PC+$08" link OUTPUT_PCP2}
        @{"Output: Show PC+$0C" link OUTPUT_PCP3}
        @{"Output: Show PC+$10" link OUTPUT_PCP4}
        @{"Output: Show PC+$14" link OUTPUT_PCP5}
        @{"Output: Show PC+$18" link OUTPUT_PCP6}
        @{"Output: Show PC+$1C" link OUTPUT_PCP7}
        @{"Output: Show PC-$04" link OUTPUT_PCM1}
        @{"Output: Show PC-$08" link OUTPUT_PCM2}
        @{"Output: Show PC-$0C" link OUTPUT_PCM3}
        @{"Output: Show PC-$10" link OUTPUT_PCM4}
        @{"Output: Show PC-$14" link OUTPUT_PCM5}
        @{"Output: Show PC-$18" link OUTPUT_PCM6}
        @{"Output: Show PC-$1C" link OUTPUT_PCM7}
        @{"Output: Show PC-$20" link OUTPUT_PCM8}
        @{"Output: Stack Dump" link OUTPUT_STACK}
        @{"Output: Stack Word" link OUTPUT_STACKWORD}
        @{"Output: Task name" link OUTPUT_RELEASENAME}
        @{"Output: User stack pointer" link OUTPUT_USP}
        @{"Hit: Task ..: stack overflow" link HIT_OVERFLOW}

        P...

        @{"Option: POSTSIZE" link OPTION_POSTSIZE}
        @{"Option: PRESIZE" link OPTION_PRESIZE}
        @{"Option: PRIORITY" link OPTION_PRI}
        @{"Option: PROTECTPOST" link OPTION_PROTECTPOST}
        @{"Common Problems" link Problems}
        @{"Output: Program Counter" link OUTPUT_PC}

        Q...

        @{"Option: QUIT" link OPTION_QUIT}

        R...

        @{"Hit: Rear mung-wall at .. is damaged" link HIT_BROKENWALL}
        @{"Hit: Release of ..: alloc. length .. <> released length .." link HIT_BADSIZE}
        @{"Hit: Release of ..: allocation pool .. <> release pool .." link HIT_BADPOOL}
        @{"MuGuardianAngel restrictions" link RESTRICTIONS}
        @{"Output: Return PC of the allocating function" link OUTPUT_PCA}

        S...

        @{"Output: SegTracker" link OUTPUT_SEGTRACKER}
        @{"Output: SegTracker Address" link OUTPUT_SEGTRACKERADDRESS}
        @{"Output: SegTracker Name" link OUTPUT_SEGTRACKERNAME}
        @{"Option: SHOWFAIL" link OPTION_SHOWFAIL}
        @{"Option: SHOWHUNK" link OPTION_SHOWHUNK}
        @{"Output: Show PC" link OUTPUT_SHOWPC}
        @{"Output: Show PC+$00" link OUTPUT_PCP0}
        @{"Output: Show PC+$04" link OUTPUT_PCP1}
        @{"Output: Show PC+$08" link OUTPUT_PCP2}
        @{"Output: Show PC+$0C" link OUTPUT_PCP3}
        @{"Output: Show PC+$10" link OUTPUT_PCP4}
        @{"Output: Show PC+$14" link OUTPUT_PCP5}
        @{"Output: Show PC+$18" link OUTPUT_PCP6}
        @{"Output: Show PC+$1C" link OUTPUT_PCP7}
        @{"Output: Show PC-$04" link OUTPUT_PCM1}
        @{"Output: Show PC-$08" link OUTPUT_PCM2}
        @{"Output: Show PC-$0C" link OUTPUT_PCM3}
        @{"Output: Show PC-$10" link OUTPUT_PCM4}
        @{"Output: Show PC-$14" link OUTPUT_PCM5}
        @{"Output: Show PC-$18" link OUTPUT_PCM6}
        @{"Output: Show PC-$1C" link OUTPUT_PCM7}
        @{"Output: Show PC-$20" link OUTPUT_PCM8}
        @{"Option: SHOWPC" link OPTION_SHOWPC}
        @{"Option: SHOWSTACK" link OPTION_SHOWSTACK}
        @{"Option: SNOOP" link OPTION_SNOOP}
        @{"Output: Stack Dump" link OUTPUT_STACK}
        @{"Output: Stack Word" link OUTPUT_STACKWORD}
        @{"Option: STACKCHECK" link OPTION_STACKCHECK}
        @{"Option: STACKLINES" link OPTION_STACKLINES}
        @{"Option: STACKSNOOP" link OPTION_STACKSNOOP}
        @{"System patches installed by MuGuardianAngel" link PATCHES}

        T...

        @{"Option: TASK" link OPTION_TASK}
        @{"Output: Task name" link OUTPUT_RELEASENAME}
        @{"The THOR-Software Licence" link LICENCE}
        @{"Option: TINY" link OPTION_TINY}
        @{"Option: TOMUFORCE" link OPTION_TOMUFORCE}
        @{"Command line options and tooltypes" link CONFIG}

        U...

        @{"Hit: Task ..: stack underflow" link HIT_UNDERFLOW}
        @{"Output: User stack pointer" link OUTPUT_USP}

        W...

        @{"Option: WAIT" link OPTION_WAIT}
        @{"Option: WAITFORMUFORCE" link OPTION_WAITFORMUFORCE}
        @{"What's the job of MuGuardianAngel?" link OVERVIEW}
        @{"What's the MMU.library?" link MMUOVERVIEW}


@{BODY}
@ENDNODE
@NODE History "History"

Release 40.1:

This is the first official release. MuGuardianAngel is a remake of the
original CBM "GuardianAngel" program. But unlike this program,
MuGuardianAngel works. (-: It combines the features of MungWall, MemSniff
and GuardianAngel in a mmu.library conformal program.


Release 40.2:

Fixed a problem on installation that caused a few "bogus" exceptions,
dependent on the installed software.


Release 40.3:

Changed the output style of the SegTracker lines a bit, back to the old
style to be compatible with tools interpreting this automatically.


Release 40.4:

Made the error messages more verbose, added more information to the
"hit" header. Fixed a tiny bug in one of the hits which could have
reported a wrong stack pointer.


Release 40.10:

Fixed a bug in the SHOWSTACK option. Made the timer handling slightly more
careful. Added the DISPC and DISRANGE options via the disassembler.library.


Release 40.11:

Fixed a bug in the MemHeader free count mismatch error handler, did not
restore one register properly and hence caused subsequent hits.


Release 40.14:

Fixed a bug in the MemHeader free count mismatch output, the memheader
argument was not forwarded correctly to the output routine and the error
message was hence broken. Added explicit checks whether the MuGuardianAngel
patches have been overwritten. MuGuardianAngel will warn you now in case
this happens, and hence someone is asking for trouble.


Release 40.15:

I was puzzled to find that some system handlers are really low on stack and
might easely cause stack overflows if run with MuGuardianAngel. The 40.15
release is now smart enough to hold and offer a tiny - but large enough -
"emergency stack" which is used in case MuGuardianAngel detects this
situation. Furthermore, a warning message will be printed. Problematic tasks
are the FFS(!) and the system RAM-DISK(!), both because they're too low on
stack. The first must be fixed by hand, by a HD installation utility, the
second by "PatchRAM", which is part of the distribution. Futhermore, stack
snooping has been extended to the memory allocation functions.


Release 40.20:

Added the "ALLOWREUSE" option to keep MuGuardianAngel happy even if a
program accesses memory after releasing it with FreeMem() without proper
Forbid()ing before. Note that programs that attempt to do so are
@{B}buggy@{UB}. Added the "NOMMU" option to turn off the MMU magic, even
though a working MMU is still checked on startup. Added consistency checks
in front of the memory allocation and release functions for optimal safety.
Added checks for the memory pool functions - these procedures are now
snooped and watched as well.


Release 40.21:

The CreatePool() patch treated a puddle size equal to the thresh size as an
error. I still regard this as a "not so smart" idea to make the thresh size
that large, but MGA accepts this now for compatibility reasons. Made some
information/debug messages more informal by including more information.
Added a consistency check in front of the AllocMem()/FreeMem() and other
functions to inform the user as early as possible about problems.


Release 40.23:

Found out that the layers.library kludge is no longer required for V40 (and
maybe, too, for V39, but I can't test it). It is therefore disabled if
MuGuardianAngel is run under V40 or better.


Release 40.24:

Fixed the shutdown code which tried to release memory thru the already
removed MuGuardianAngel patches. Thanks to Stephan Rupprecht for finding and
describing the bug.


Release 40.25:

Added the "DUMPWALL" option to print details about a broken mungwall or a
broken memory cookie, made the mung wall error messages more explicit. Added
an information line how memory was allocated if a "PCa" is available.


Release 40.26:

MuGuardianAngel prints now the stack limits in case an out-of-stack or
nearly out of stack condition was found. Thanks for the idea, Heinz. Added
another option to disable the "nearly out of stack" warning messages.
BEWARE! It just makes MuGuardianAngel @{B}NOT@{UB} to report a problem,
hence downgrades it.


Release 40.28:

Due to a bug in the mung-wall logic, MuGuardianAngel could have reported an
additional bogus "rear mung wall broken" hit in case just the front wall was
damaged. MuGuardianAngel sets now all valid pages explicitly to "USED" and
"MODIFIED", avoiding additional MMU descriptor updates. Besides that this
optimizes the performance a bit, it will also work around a possible
firmware bug in some early releases of the 68060. The MuGuardianAngel patch
report and automatic IRQ check have been reworked a bit. The "patches
overwritten" message is now no longer periodically generated, but will be
suspended up to the next "real" hit where another message will be generated.
The MuGuardianAngel automatic IRQ stack was not only useless, but in fact
broken. This does not go for the stack check of the exec memory handling
functions which was and still is fine. Good enough it was recommended to
leave the IRQ check disabled. "Nearly out of stack" warnings were not
generated by the IRQ code at all, and the stack overflow and stack underflow
messages usually report "bogus" hits due to its construction. Stack snooping
is now by default ENABLED, except for "out of bounds" reports, which still
requires STACKSNOOP option explicitly. Added an option to adjust the minimal
stack size for the "Nearly out of stack" reports, but it can be made only
larger, i.e. more "picky".


Release 40.29:

Does no longer use RawIOInit() since this breaks programs that opened
the serial port already. This means that MuGuardianAngel does now
require that the Os will do this instead on bootup, similar to the
Enforcer.


Release 40.30:

Fixed a bug in the MUNGLIST option which sometimes failed to allocate enough
memory to present the full list. This has been fixed now.


Release 40.33:

MuGuardianAngel uses now the SegTracker to identify the return PC with
a segment/offset index for the MungList option. MuGuardianAngel did
not print the return PC for the pooled memory allocation functions
correctly.


Release 40.48:

MuGuardianAngel stops now MuForce from exiting as long as it is running.
Added the PROTECTPOST command line option. Fixed broken AllocAbs()
replacement of former releases. Fixed possible misalignment for Allocate()
and Deallocate().


Release 40.5:

This version is a re-release of the version Christian Sauer fixed. It
merges all developments back into the main branch, but does not include
further functionalities.


Release 40.51:

The 40.51 release of MuGuardianAngel only fixes a tiny bug that was
detected by Alexander Benedictov, namely that MuGA failed to check
on exit whether AllocAbs() was patched over. This release adds the
missing check. Thanks, Sascha!

@ENDNODE

