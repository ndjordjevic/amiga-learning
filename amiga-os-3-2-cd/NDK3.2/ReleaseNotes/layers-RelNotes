------------ AmigaOS 4 project + Third party development -------------

- Updates for release 44.1 (commit log unavailable)

- Layers v40 and before has been mixed assembly
and C (of mixed quality). The major problem was
that layers depended on a compiler that did not
trash a6 during library calls, something that
cannot be savely assumed. V44 is a recompile,
with the assembly parts replaced by apropriate
C functions, with the exception of the library
startup code (which would be easy to deal with).
Unfortunately, this means that some assembly
optimizations Mike Sinz did had to go. The V44
layers will therefore require a bit more stack
for safe operation.

- Rewrote layers "low memory" handling completely.
The V44 layers no longer requires the ugly V40
setjmp/longjmp type support for handling low-memory
situations and will be able to deal with them in a
very much cleaner and more orthogonal approach. The
layers.library now buffers ClipRects in a much
better sense than the old layers could and should
therefore possibly avoid memory fragmentation. It
is likely that some "race conditions" caused by the
old layers allocation mechanism now no longer apply.

- As a result of the above, the old and nasty
FattenLayerInfo() and ThinLayerInfo() calls are
completely obsolete. Layer_Info suffices to be as
large as in v32 again, back to the future! Never-
theless, users are ought to call NewLayerInfo()
instead (as always), and if that cannot be done
for obscure reasons (intuition) ought to call 
ThinLayerInfo at least before disposing the 
Layer_Info manually.

- On/Off-screen swapping of ClipRects resp. their
buffers respects now graphics cards. Instead of
the nice, but planar oriented "double Xor" swap,
layers.library tries now to use a second off-screen
buffer if the bitmap format is non-native. This
helps improving the performance. Especially, this
makes the Picasso96 "fastlayers.library" obsolete.

- NDK changes: Updated graphics/clip.h and
graphics/layers.h to match a new naming convention.
Note that both really describe layer internals you
shouldn't care about anyhow. 
If you depend on these, fry! Things have changed,
did change and will continue to change. I'll only
guarantee stability of the graphics relevant parts
of the cliprect, namely its bitmap, bounds and 
next pointer. Everything else is *private*.

- Things to be tested: Almost everything, but
especially handling of low-memory situations and
proper memory handling. Note that layers recycles
cliprects quite a lot - these will not be given
back immediately. Cleanups happen on each 
DeleteLayer() (i.e. close of a window) or on each
DeleteLayerInfo() resp. ThinLayerInfo().

- Things to be done: Lots and lots. The cliprect
handling is somewhat brain-dead and generates way
way too many clips. It also involves way to many
copy operations on layer creation and deletion.

- Updates for release 44.2 (commit log unavailable)

- Comparisons for SortLayerCR where wrong for diagonal 
scrolling directions. This caused display distortions
on window movements in diagonal directions.
Fixed.

- Updates for release 45.1 (commit log unavailable)

- This is the first "smart" version of layers with
an optimized layer "moveinfrontof" code. The old
code cut cliprects at the "shadow" of all layers, 
which was kind of stupid and caused quite a lot of
"slice and dice" operations on creation and deletion
of windows. Layers 45.1 should be much better in
this respect as it only tries to touch the layers
it absolutely has to. The price for this is that
the layers rearrangement code is more complex than
before.

- Layers "moveinfrontof" rewritten completely. 

- Layers no longer keeps empty cliprects in simple 
layers for image parts that are obscured anyhow.
They just clug up the layer cliprect list.

- "newlayer" partially rewritten to make use of
the new layer arrangement code. Much simpler now.

- "deletelayer" partially rewritten for the same
reason.

- "movesizelayer" partially rewritten for new
layer arrangement code.

- "begin/endupdate" partially rewritten.

- The V34 dedicer is now obsolete. In fact, it
is no longer required. Layers now keeps its layers
in a clean and very arranged state all the time.

- Lots and lots of obsolete code removed.

BUGS: Note that all of these are old bugs, not new ones.
-BeginUpdate() may fail for out-of-memory
reasons. This is unfortunately an old design bug
I cannot easily cure in V45. 
-InstallUserClipRect(): 
Installation of user cliprects is discouraged.
Unfortunately, the broken V34 design is still
lurking thru the code and may cause wonderful
effects if layers runs low on memory. I currently
don't see a good way how to cure this illness.
- MoveSizeLayer() for LAYERSMART layer types 
might still require some improvement.
- SwapBitsClipRectRastPort() might still require
an improvement, avoiding the "tripple XOR"
method when applicable.
- SortLayerCR() might still require an improvement.
It currently uses a plain and stupid insertion
sort. It's currently not a major speed brake, though.
- layers initialization code: Unfortunately, the
code cannot safely Alert() in case a problem on setup
is generated. Alert() calls the grahics.library, which
in turn requires layers. *sigh*
- layers initialization code: Must unfortunately use
a FindName() on the library list to look for graphics.
As graphics opens layers in its init code, there's no
other way of doing that. *sigh*
- There's still some cleanup to be done.

- Updates for release 45.2 ()

- More cleanup; obsolete V40 superbitmap code was
finally removed. Superbitmap support no longer requires
a recursive routine.

- Found that the P96 rtg.library PIP support depends
on the fact that obscured simple refresh layers have
at least one dummy cliprect with lobs!=NULL. This is
no longer the case for V45 and above. A fix for the
rtg.library is available separately.

- movesizelayer partially reworked again. The update
mechanism for obscured layer parts is now a bit
smarter and will avoid double backfill and hence some
flicker.

- layer rearrangement code revised again: It now
only touches the absolute minimum amount of
layers for further speedup.

- Updates for release 45.3 (commit log unavailable)

- More cleanup: createlayer is now much more light-
weighted as all the cliprect creation handling is
done by ToMiddle anyhow.

- Memory Management: Layers identifies now its own
cliprects by a pointer to the "home" Layer_Info.
This way, user-hacked cliprects never enter the
layers internal scratch list of recycled cliprects.

- Memory Management: ClipRect management is now
a bit more leightweighted.

- CreateBehindLayer(hook): Did not allocate backing
store correctly for LAYERSMART layers.

- Upfront/Behind/ToMiddle: Could return failure
in case the layer movement target was NULL to
move to background. Fixed.

- New layer function LayerOccluded(): This returns
TRUE in case the layer is not fully visible. Use-
ful applications are the rtg.library PIP window
handling.

- New layer function pair: HideLayer(), ShowLayer().
These functions make a layer completely invisible
or restore it completely, keeping care of all the
damage/backing store modifications. The function
pair is designed for intuition "window iconfication"
code that still has to come. See also the example
program "AmiSnip" to demonstrate how this works.

- New layer function: SetLayerInfoBounds(). This
installs an additional clipping of layers on
new LayerInfo bounds. The purpose of this function
is to allow off-screen layers, i.e. to allow
intuition to move layers off-screen savely. See the
example program "Clippy" to find out how this
works.

- Updates for release 45.4 (commit log unavailable)

Layers update/usercliprect system has been rewritten
completely now. The old system could have destroyed
the layer cliprects in low-memory situations. Especially,
LockLayers() and UnlockLayers() required quite some
memory for layers with user cliprects installed, and
they could have failed in certain situations. This
has been fixed now.
Note that the changes in the cliprect management are
rather heavy such that the 45.4 must be carefully
tested.
Layers "slice and dice" algorithm has been improved
and tries now to combine adjacent cliprects to reduce
the overall amount of cliprects. Unfortunately, the
resulting algorithm is O(N^3), but even for a larger
number of layers, the time for copying bitmaps
around is dominating. This optimization will make
rendering algorithms, especially the gfx line drawer,
faster.

- Updates for release 45.5 (commit log unavailable)

Layers Create...Layer() forgot to clear the update
flags for simple refresh layers after having build
the layer. This broke the initial refresh of some
MUI apps successfully. Fixed.

- Updates for release 45.11 (commit log unavailable)

FilterClipRects() has been optimized for layers that
are neither in refresh state nor provide user
clip rects. No other changes.
Fixed a potential memory leak in newlayer().
newlayer() now pre-allocates some cliprects to avoid
memory fragmentation.

- Updates for release 45.13 (commit log unavailable)

Optimized MoveSizeLayer(): A layer move operation is
now able to work with a single BltBitMap() operation.
This should speedup up the most common case of a 
MoveWindow().

- Updates for release 45.14 (commit log unavailable)

Layers V45 no longer used the obsolete NEWCLIPRECTS
flag that marked cliprects four bytes longer. Seems
this caused problems in V50 intuition that expected
shorter cliprects (huh!). Layers 45.14 builds now
cliprects four bytes shorter and doesn't require
the additional bytes anyhow.

- Updates for release 45.17 (commit log unavailable)

Added two new private function slots for allocating
and releasing cliprects. Note that only intuition
(or at best noone) should call them. There is no
need to mess with cliprects yourself.

- Updates for release 45.18 (commit log unavailable)

Allocates RastPorts now again a bit larger as to
conform to pre-1.2 programs (this shouldn't really
matter too much).
Layers.library now pools ClipRects in a second 
level by using the exec memory pools. Note that
this is experimental as it is not too unlikely that
programs allocating their own ClipRects might cause
problems. Layers tries to identify these cliprects
and handles them the old way then.

- Updates for release 45.19 (commit log unavailable)

Fixed a memory loss by not releasing rastports and layers
by exactly the same byte size they have been allocated
with. The problem was caused by not removing the 
GFX_RASTPORTS_1_2 consistently amongst modules.

-------------------- AmigaOS 3.1.4.(1) project -----------------------

- Updates for release 45.28 (18.12.2016)

No functional change, this is just a plain reintegration of the 45.27
layers from the sources. Unfortunately, the make architecture was
diverging, so a couple of minor changes had to be made to support the
native build process. The startup code had to be changed to support
the (less capable) SC "asm" as it does not allow short relocations of
LVOs.

I also tried to use DATA=FAR as build-process, though the code did
not become any better, just a bit larger. So it will stay as is
in the "hacky" way of mis-using _LINKERDB as library base. It works.

- Updates for release 45.29 (12.8.2017)

Compiler options changed again working without LIBCODE, and loading the
base register manually in all library interface functions. This
generates slightly smaller code.

- Updates for release 45.30 (31.7.2018)

InstallClipRect() optimized an attempt to re-install the same 
ClipRegion away to nothing. Unfortunately, some games seem to assume 
that they can modify a ClipRegion while it is installed, and then 
assume that layers refreshes the clipping when called like this. I 
don't want to break things unnecessary, so rebuilding clipping in such 
a case is now enforced as well.

------------------------ AmigaOS 3.2 project -------------------------

- Updates for release 46.1 (4.8.2019):

Bumped to V46 to enable automatic loading on Os 3.2.

- Updates for release 46.2 (18.12.2019):

Fixed a bug in MoveSizeLayers() that for particular coordinate 
combinations did not preserve the contents of SimpleRefresh layers, 
just by a stupid coordinate mixup. Made a couple of minor optimizations 
to reduce the size.
